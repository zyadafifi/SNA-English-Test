<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Speak About the Photo - SNA English Test Practice</title>

    <!-- Resource Hints for Performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link rel="dns-prefetch" href="https://fonts.googleapis.com" />

    <!-- Preload Critical Assets -->
    <link
      rel="prefetch"
      href="speak about the photo data.json"
      as="fetch"
      type="application/json"
    />

    <!-- Optimized Font Loading -->
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
      rel="stylesheet"
      media="print"
      onload="this.media='all'"
    />
    <noscript>
      <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
        rel="stylesheet"
      />
    </noscript>
    <link rel="stylesheet" href="background.css" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, sans-serif;
        background-color: #f8f9fa;
        min-height: 100vh;
        line-height: 1.6;
        color: #334155;
      }
      img {
        width: 450px;
        height: 300px;
      }
      .mic-icon {
        margin-right: 8px;
      }

      /* Loading Screen */
      .loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #f8f9fa;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      .loading-screen > div {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 20px;
      }

      .loading-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #e0e0e0;
        border-top: 4px solid #ffc515;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        flex-shrink: 0;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .loading-text {
        font-size: 16px;
        color: #6b7280;
        text-align: center;
        margin: 0;
      }

      /* Error Screen */
      .error-screen {
        display: none;
        text-align: center;
        padding: 40px;
        background-color: #ffebee;
        border-radius: 12px;
        border: 1px solid #f44336;
        margin: 20px;
      }

      .error-title {
        font-size: 24px;
        font-weight: 600;
        color: #f44336;
        margin-bottom: 10px;
      }

      .error-message {
        color: #6b7280;
        margin-bottom: 20px;
      }

      .retry-data-btn {
        background: #ffc515;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s;
      }

      .retry-data-btn:hover {
        background: #ffb300;
      }

      /* Quiz Container */
      .quiz-container {
        max-width: 100%;
        margin: 0 auto;
        padding: 40px;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: transparent;
      }

      /* Question Card */
      .question-card {
        background: white;
        border-radius: 12px 12px 0 0;
        padding: 50px 60px;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
        width: 100%;
        max-width: 1200px;
        text-align: center;
        position: relative;
        min-height: 600px;
        display: flex;
        margin: 0 auto;
        margin-bottom: 0;
        box-sizing: border-box;
        flex-direction: column;
        justify-content: center;
      }

      /* Timer */
      .timer {
        position: absolute;
        top: 30px;
        left: 30px;
        background: transparent;
        padding: 0;
        border-radius: 0;
        font-weight: 400;
        color: #888;
        font-size: 16px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .timer-icon {
        width: 20px;
        height: 20px;
        fill: currentColor;
      }

      .timer.warning {
        color: #f44336;
        font-weight: 600;
      }

      /* Close Button */
      .close-btn {
        position: absolute;
        top: 25px;
        right: 25px;
        background: none;
        border: none;
        cursor: pointer;
        padding: 8px;
        border-radius: 4px;
        transition: background 0.2s;
        color: #ddd;
      }

      .close-btn:hover {
        background: #f8f8f8;
      }

      /* Progress Bar */
      .stage-progress-bar {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 30px;
        width: 100%;
        max-width: 400px;
        margin-left: auto;
        margin-right: auto;
      }

      .progress-track {
        flex: 1;
        height: 8px;
        background: #e0e0e0;
        border-radius: 4px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        background: #ffc515;
        border-radius: 4px;
        transition: width 0.3s ease;
        width: 0%;
      }

      .progress-text {
        font-size: 14px;
        color: #666;
        font-weight: 500;
        min-width: 45px;
        text-align: right;
      }

      /* Question Content */
      .question-title {
        font-size: 28px;
        font-weight: 400;
        color: #6b7280;
        margin-bottom: 20px;
        line-height: 1.2;
      }

      .question-subtitle {
        font-size: 16px;
        color: #888;
        margin-bottom: 40px;
      }

      /* Photo Container */
      .photo-container {
        margin-bottom: 40px;
        display: flex;
        justify-content: center;
      }

      .photo-image {
        max-width: 100%;
        max-height: 300px;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }

      /* Record Button */
      .record-button {
        background: #ffc515;
        color: white;
        border: none;
        padding: 16px 32px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s;
        text-transform: uppercase;
        letter-spacing: 1px;
        display: flex;
        align-items: center;
        gap: 8px;
        justify-content: center;
        margin: 0 auto;
        min-width: 180px; /* Ensure minimum width */
        white-space: nowrap; /* Prevent text wrapping */
      }

      .record-button:hover {
        background: #ffb300;
        transform: translateY(-2px);
      }

      .record-button.recording {
        background: #f44336;
        animation: pulse 1.5s infinite;
      }

      @keyframes pulse {
        0% {
          box-shadow: 0 4px 20px rgba(244, 67, 54, 0.3);
        }
        50% {
          box-shadow: 0 4px 30px rgba(244, 67, 54, 0.6);
        }
        100% {
          box-shadow: 0 4px 20px rgba(244, 67, 54, 0.3);
        }
      }

      /* Audio Visualization */
      .audio-visualizer {
        margin: 20px 0;
        display: none;
        justify-content: center;
        align-items: center;
        gap: 4px;
      }

      .audio-bar {
        width: 4px;
        background: #ffc515;
        border-radius: 2px;
        animation: audioWave 1s ease-in-out infinite;
      }

      .audio-bar:nth-child(1) {
        height: 20px;
        animation-delay: 0s;
      }
      .audio-bar:nth-child(2) {
        height: 30px;
        animation-delay: 0.1s;
      }
      .audio-bar:nth-child(3) {
        height: 25px;
        animation-delay: 0.2s;
      }
      .audio-bar:nth-child(4) {
        height: 35px;
        animation-delay: 0.3s;
      }
      .audio-bar:nth-child(5) {
        height: 20px;
        animation-delay: 0.4s;
      }
      .audio-bar:nth-child(6) {
        height: 30px;
        animation-delay: 0.5s;
      }

      @keyframes audioWave {
        0%,
        100% {
          transform: scaleY(1);
        }
        50% {
          transform: scaleY(0.5);
        }
      }

      /* Continue Button */
      .continue-btn {
        background: #ffc515;
        color: white;
        border: none;
        padding: 14px 28px;
        border-radius: 9999px;
        font-size: 16px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s;
        text-transform: uppercase;
        letter-spacing: 1px;
        position: absolute;
        bottom: 30px;
        right: 30px;
      }

      .continue-btn:hover {
        background: #ffb300;
      }

      .continue-btn:disabled {
        background: #e0e0e0;
        color: #999;
        cursor: not-allowed;
      }

      /* Review Section */
      .review-section {
        background: #ffe8b0;
        border-radius: 12px;
        padding: 28px 40px 80px 40px;
        margin: 20px auto 0 auto;
        border: none;
        display: none;
        position: relative;
        width: 100%;
        max-width: 900px;
        box-sizing: border-box;
        text-align: left;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
      }

      .review-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 16px;
      }

      .review-icon {
        width: 20px;
        height: 20px;
        flex-shrink: 0;
        fill: #2e7d32;
      }

      .review-title {
        font-size: 16px;
        font-weight: 700;
        margin: 0;
        color: #2e7d32;
      }

      .review-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-top: 16px;
        justify-content: flex-start;
      }

      .sample-btn,
      .recording-btn {
        background: white;
        color: #ffc515;
        border: 2px solid #ffc515;
        padding: 10px 18px;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 6px;
        white-space: nowrap;
        min-width: 120px;
        justify-content: center;
      }

      .sample-btn:hover,
      .recording-btn:hover {
        background: #ffc515;
        color: white;
      }

      .sample-btn.playing,
      .recording-btn.playing {
        background: #f44336;
        border-color: #f44336;
        color: white;
      }

      .play-icon,
      .stop-icon {
        width: 14px;
        height: 14px;
        fill: currentColor;
      }

      /* Continue Button in Review */
      .continue-review-btn {
        background: #ffc515;
        color: white;
        border: none;
        padding: 14px 24px;
        border-radius: 9999px;
        font-size: 14px;
        font-weight: 700;
        cursor: pointer;
        transition: background 0.2s;
        text-transform: uppercase;
        letter-spacing: 1px;
        position: absolute;
        bottom: 24px;
        right: 24px;
      }

      .continue-review-btn:hover {
        background: #ffb300;
      }

      /* Results Screen */
      .results-screen {
        display: none;
        text-align: center;
        background: white;
        border-radius: 12px;
        padding: 80px 60px;
        box-shadow: 0 4px 24px rgba(0, 0, 0, 0.08);
        width: 100%;
        max-width: 600px;
        min-height: 400px;
        position: relative;
      }

      .results-icon {
        width: 80px;
        height: 80px;
        margin: 0 auto 40px;
        background: #ffc515;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }

      .results-icon svg {
        width: 40px;
        height: 40px;
        fill: white;
      }

      .results-title {
        font-size: 24px;
        font-weight: 500;
        color: #777;
        margin-bottom: 10px;
        line-height: 1.3;
      }

      .results-subtitle {
        font-size: 18px;
        font-weight: 400;
        color: #777;
        margin-bottom: 60px;
      }

      .results-buttons {
        display: flex;
        flex-direction: row;
        gap: 16px;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        margin-top: 40px;
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
      }

      .results-buttons .results-continue-btn,
      .results-buttons .done-btn {
        position: static;
        bottom: auto;
        right: auto;
        left: auto;
      }

      .results-continue-btn {
        background: white;
        color: #ffc515;
        border: 2px solid #ffc515;
        padding: 14px 28px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .results-continue-btn:hover {
        background: #fff8e1;
      }

      .done-btn {
        background: #ffc515;
        color: white;
        border: none;
        padding: 14px 28px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 700;
        cursor: pointer;
        transition: background 0.2s;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .done-btn:hover {
        background: #ffb300;
      }

      /* Responsive Design */
      /* Enhanced Responsive Design */
      @media (max-width: 768px) {
        .quiz-container {
          padding: 15px;
        }

        .question-card {
          padding: 30px 25px;
          min-height: 500px;
          max-width: 100%;
          border-radius: 12px 12px 0 0;
        }

        .question-title {
          font-size: 22px;
          margin-bottom: 16px;
          line-height: 1.3;
        }

        .question-subtitle {
          font-size: 15px;
          margin-bottom: 30px;
        }

        /* Photo improvements for tablets */
        .photo-container {
          margin-bottom: 30px;
          padding: 0 15px;
        }

        .photo-image {
          max-height: 250px;
          border-radius: 10px;
        }

        /* Record button for tablets */
        .record-button {
          padding: 14px 28px;
          font-size: 15px;
          min-width: 160px;
          gap: 6px;
        }

        .mic-icon svg {
          width: 20px;
          height: 20px;
        }

        /* Audio visualizer */
        .audio-visualizer {
          margin: 18px 0;
        }

        .audio-bar {
          width: 3px;
        }

        /* Review section for tablets */
        .review-section {
          padding: 24px 25px 75px 25px;
          margin: 15px auto 0 auto;
          border-radius: 10px;
        }

        .review-buttons {
          gap: 10px;
          justify-content: center;
        }

        .sample-btn,
        .recording-btn {
          padding: 9px 16px;
          font-size: 13px;
          min-width: 110px;
        }

        /* Button positioning */
        .continue-btn,
        .continue-review-btn,
        .done-btn {
          bottom: 20px;
          right: 20px;
          padding: 12px 24px;
          font-size: 14px;
        }

        .timer {
          top: 20px;
          left: 20px;
          font-size: 14px;
        }

        .close-btn {
          top: 15px;
          right: 15px;
        }
      }

      @media (max-width: 480px) {
        .quiz-container {
          padding: 10px;
        }

        .question-card {
          padding: 25px 20px;
          min-height: 450px;
          border-radius: 12px 12px 0 0;
        }

        .question-title {
          font-size: 20px;
          margin-bottom: 14px;
          line-height: 1.2;
        }

        .question-subtitle {
          font-size: 14px;
          margin-bottom: 25px;
        }

        /* Photo improvements for mobile */
        .photo-container {
          margin-bottom: 25px;
          padding: 0 10px;
        }

        .photo-image {
          max-height: 200px;
          border-radius: 8px;
          width: 100%;
          max-width: 280px;
        }

        /* Record button for mobile */
        .record-button {
          padding: 12px 24px;
          font-size: 14px;
          min-width: 140px;
          gap: 4px;
        }

        .mic-icon svg {
          width: 18px;
          height: 18px;
        }

        /* Audio visualizer for mobile */
        .audio-visualizer {
          margin: 16px 0;
          gap: 3px;
        }

        .audio-bar {
          width: 2px;
        }

        .audio-bar:nth-child(1) {
          height: 16px;
        }
        .audio-bar:nth-child(2) {
          height: 24px;
        }
        .audio-bar:nth-child(3) {
          height: 20px;
        }
        .audio-bar:nth-child(4) {
          height: 28px;
        }
        .audio-bar:nth-child(5) {
          height: 16px;
        }
        .audio-bar:nth-child(6) {
          height: 24px;
        }

        /* Review section for mobile */
        .review-section {
          padding: 20px 18px 70px 18px;
          margin: 12px 8px 0 8px;
          border-radius: 8px;
        }

        .review-header {
          gap: 8px;
          margin-bottom: 14px;
        }

        .review-icon {
          width: 18px;
          height: 18px;
        }

        .review-title {
          font-size: 15px;
        }

        .review-buttons {
          gap: 8px;
          flex-direction: column;
          align-items: stretch;
        }

        .sample-btn,
        .recording-btn {
          padding: 12px 16px;
          font-size: 13px;
          min-width: auto;
          width: 100%;
          justify-content: center;
        }

        .play-icon,
        .stop-icon {
          width: 12px;
          height: 12px;
        }

        /* Button positioning for mobile */
        .continue-btn,
        .done-btn {
          bottom: 18px;
          right: 18px;
          left: 18px;
          width: calc(100% - 36px);
          padding: 14px 20px;
          font-size: 14px;
          text-align: center;
        }

        .continue-review-btn {
          position: relative;
          bottom: auto;
          right: auto;
          left: auto;
          width: 100%;
          margin: 20px 0 0 0;
          padding: 14px 20px;
          font-size: 14px;
        }

        .timer {
          top: 18px;
          left: 18px;
          font-size: 13px;
        }

        .timer-icon {
          width: 16px;
          height: 16px;
        }

        .close-btn {
          top: 12px;
          right: 12px;
          padding: 6px;
        }

        .close-btn svg {
          width: 16px;
          height: 16px;
        }

        /* Results screen for mobile */
        .results-screen {
          padding: 40px 25px;
          margin: 10px;
        }

        .results-icon {
          width: 60px;
          height: 60px;
          margin-bottom: 30px;
        }

        .results-icon svg {
          width: 30px;
          height: 30px;
        }

        .results-title {
          font-size: 20px;
          margin-bottom: 8px;
        }

        .results-subtitle {
          font-size: 16px;
          margin-bottom: 40px;
        }
      }

      @media (max-width: 360px) {
        /* Extra small mobile devices */
        .question-card {
          padding: 20px 15px;
        }

        .question-title {
          font-size: 18px;
        }

        .photo-image {
          max-height: 180px;
          max-width: 260px;
        }

        .record-button {
          padding: 10px 20px;
          font-size: 13px;
          min-width: 120px;
        }

        .review-section {
          padding: 18px 15px 65px 15px;
        }
      }

      /* Landscape orientation fixes for mobile */
      @media (max-width: 768px) and (orientation: landscape) {
        .photo-image {
          max-height: 160px;
        }

        .question-card {
          min-height: 400px;
        }

        .photo-container {
          margin-bottom: 20px;
        }

        .stage-progress-bar {
          gap: 8px;
          max-width: 100%;
          margin-bottom: 20px;
        }

        .progress-track {
          height: 6px;
        }

        .progress-text {
          font-size: 12px;
          min-width: 35px;
        }

        .loading-spinner {
          width: 32px;
          height: 32px;
          border-width: 3px;
        }

        .loading-screen > div {
          gap: 16px;
        }

        .loading-text {
          font-size: 14px;
        }
      }

      /* High DPI displays */
      @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
        .photo-image {
          image-rendering: -webkit-optimize-contrast;
          image-rendering: crisp-edges;
        }
      }
    </style>
  </head>
  <body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
      <div>
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading quiz data...</div>
      </div>
    </div>

    <!-- Error Screen -->
    <div class="error-screen" id="errorScreen">
      <div class="error-title">Failed to Load Quiz Data</div>
      <div class="error-message" id="errorMessage">
        Could not load the quiz questions. Please check your internet connection
        and try again.
      </div>
      <button class="retry-data-btn" onclick="loadQuizData()">Retry</button>
      <button
        class="retry-data-btn"
        onclick="goBack()"
        style="background: #f0f0f0; color: #666; margin-left: 10px"
      >
        Go Back
      </button>
    </div>

    <div class="quiz-container" id="quizContainer" style="display: none">
      <!-- Question Card -->
      <div class="question-card" id="questionCard">
        <!-- Timer -->
        <div class="timer" id="timer">
          <svg
            class="timer-icon"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <circle cx="12" cy="12" r="10" />
            <polyline points="12,6 12,12 16,14" />
          </svg>
          <span id="timerText">0:15</span>
          <span style="color: #999; margin-left: 6px" id="timerLabel"
            >to prepare</span
          >
        </div>

        <!-- Close Button -->
        <button class="close-btn" onclick="goBack()">
          <svg
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>

        <!-- Progress Bar -->
        <div class="stage-progress-bar">
          <div class="progress-track">
            <div class="progress-fill" id="stageProgressFill"></div>
          </div>
          <span class="progress-text" id="stageProgressText">0/3</span>
        </div>

        <!-- Question Content -->
        <div class="question-content" id="questionContent">
          <h1 class="question-title" id="questionTitle">
            Prepare to speak about the image below
          </h1>

          <p class="question-subtitle" id="questionSubtitle">
            You will have 90 seconds to speak
          </p>

          <!-- Photo Container -->
          <div class="photo-container">
            <img
              class="photo-image"
              id="photoImage"
              src=""
              alt="Photo to describe"
            />
          </div>

          <!-- Record Button -->
          <button
            class="record-button"
            id="recordButton"
            onclick="handleRecord()"
          >
            <span class="mic-icon"
              ><svg
                height="24"
                preserveAspectRatio="xMidYMin slice"
                width="24"
                style="color: rgb(var(--color-snow)); overflow: visible"
                viewBox="0 0 24 24"
              >
                <path
                  fill-rule="evenodd"
                  clip-rule="evenodd"
                  d="M11.5055 0.921631C9.29632 0.921631 7.50546 2.71249 7.50546 4.92163V10.5029C7.50546 12.712 9.29632 14.5029 11.5055 14.5029H12.4973C14.7065 14.5029 16.4973 12.712 16.4973 10.5029V4.92163C16.4973 2.71249 14.7065 0.921631 12.4973 0.921631H11.5055ZM19.9809 12.4921C19.9809 11.9398 19.5332 11.4921 18.9809 11.4921C18.4286 11.4921 17.9809 11.9398 17.9809 12.4921C17.9809 14.924 16.0058 16.8983 13.566 16.8983H10.3052C7.93658 16.8983 6.01913 14.9816 6.01913 12.6206C6.01913 12.0683 5.57141 11.6206 5.01913 11.6206C4.46684 11.6206 4.01913 12.0683 4.01913 12.6206C4.01913 16.0892 6.83503 18.8983 10.3052 18.8983H10.9789V21.0783H10.2096C9.65732 21.0783 9.2096 21.526 9.2096 22.0783C9.2096 22.6305 9.65732 23.0783 10.2096 23.0783H13.9125C14.4648 23.0783 14.9125 22.6305 14.9125 22.0783C14.9125 21.526 14.4648 21.0783 13.9125 21.0783H12.9789V18.8983H13.566C17.1073 18.8983 19.9809 16.0316 19.9809 12.4921Z"
                  fill="currentcolor"
                ></path></svg
            ></span>
            <span id="recordButtonText">RECORD NOW</span>
          </button>

          <!-- Audio Visualizer -->
          <div class="audio-visualizer" id="audioVisualizer">
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
          </div>

          <!-- Continue Button -->
          <button class="continue-btn" id="continueBtn" onclick="nextStep()">
            CONTINUE
          </button>
        </div>
      </div>

      <!-- Review Section -->
      <div class="review-section" id="reviewSection">
        <div class="review-header">
          <svg
            class="review-icon"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <circle cx="12" cy="12" r="10" />
            <polyline points="16,8 10,14 8,12" />
          </svg>
          <div class="review-title">Review sample answer:</div>
        </div>

        <div class="review-buttons">
          <button class="sample-btn" id="sampleBtn" onclick="toggleSample()">
            <svg class="play-icon" id="samplePlayIcon" viewBox="0 0 24 24">
              <polygon points="5,3 19,12 5,21"></polygon>
            </svg>
            <svg
              class="stop-icon"
              id="sampleStopIcon"
              viewBox="0 0 24 24"
              style="display: none"
            >
              <rect x="6" y="4" width="4" height="16"></rect>
              <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
            <span id="sampleBtnText">SAMPLE</span>
          </button>
          <button
            class="recording-btn"
            id="recordingBtn"
            onclick="toggleRecording()"
          >
            <svg class="play-icon" id="recordingPlayIcon" viewBox="0 0 24 24">
              <polygon points="5,3 19,12 5,21"></polygon>
            </svg>
            <svg
              class="stop-icon"
              id="recordingStopIcon"
              viewBox="0 0 24 24"
              style="display: none"
            >
              <rect x="6" y="4" width="4" height="16"></rect>
              <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
            <span id="recordingBtnText">YOUR RECORDING</span>
          </button>
        </div>

        <button class="continue-review-btn" onclick="showResults()">
          CONTINUE
        </button>
      </div>

      <!-- Results Screen -->
      <div class="results-screen" id="resultsScreen">
        <div class="results-icon">
          <svg viewBox="0 0 24 24">
            <path d="M8 5V19L19 12L8 5Z" />
          </svg>
        </div>
        <div class="results-title">Practice complete! You</div>
        <div class="results-subtitle">improved your speaking skills.</div>
        <div class="results-buttons">
          <button class="results-continue-btn" onclick="continueToNextStage()">CONTINUE</button>
          <button class="done-btn" onclick="goToPractice()">DONE</button>
        </div>
      </div>
    </div>

    <!-- Hidden Audio Elements -->
    <audio id="sampleAudio" preload="auto"></audio>
    <audio id="recordingAudio" preload="auto"></audio>

    <script>
      // Quiz Data (will be loaded from JSON)
      let allQuizData = [];
      let quizConfig = {};

      // Quiz State
      let currentQuestion = null;
      let currentStep = "prepare"; // prepare, speaking, review, results
      let questionStartTime = 0;
      let timerInterval;
      let prepareTimeout;
      let recordingTimeout;
      let mediaRecorder;
      let recordedChunks = [];
      let recordedBlob = null;
      let speechSynthesis = window.speechSynthesis;
      let currentUtterance = null;
      let sampleAudio = null;
      let recordingAudio = null;
      let isPlayingSample = false;
      let isPlayingRecording = false;
      let dataLoaded = false;
      let stagesCompletedThisSession = 0;
      // Session tracking variables
      let sessionData = {
        questionId: null,
        preparationTime: 0,
        speakingTime: 0,
        totalTime: 0,
        timeUtilized: 0,
        sessionStartTime: 0,
        preparationStartTime: 0,
        speakingStartTime: 0,
      };

      // Create answers array for compatibility with analytics
      let answers = [];
      let quizData = [];
      // Configuration
      const PREPARE_TIME = 15000; // 15 seconds preparation time
      const RECORDING_TIME = 90000; // Will be loaded from JSON

      // Load Quiz Data from JSON
      async function loadQuizData() {
        try {
          showLoadingScreen();

          const response = await fetch("speak about the photo data.json");
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();

          // Validate data structure
          if (
            !data.questions ||
            !Array.isArray(data.questions) ||
            data.questions.length === 0
          ) {
            throw new Error(
              "Invalid data format: questions array is missing or empty"
            );
          }

          allQuizData = data.questions;
          quizConfig = data.config || {};

          if (allQuizData.length === 0) {
            throw new Error("No questions available in the data file.");
          }

          dataLoaded = true;
          hideLoadingScreen();
          initializeQuiz();
        } catch (error) {
          console.error("Error loading quiz data:", error);
          showErrorScreen(error.message);
        }
      }

      // Show/Hide Loading Screen
      function showLoadingScreen() {
        document.getElementById("loadingScreen").style.display = "flex";
        document.getElementById("errorScreen").style.display = "none";
        document.getElementById("quizContainer").style.display = "none";
      }

      function hideLoadingScreen() {
        document.getElementById("loadingScreen").style.display = "none";
        document.getElementById("quizContainer").style.display = "flex";
      }

      function showErrorScreen(errorMessage) {
        document.getElementById("loadingScreen").style.display = "none";
        document.getElementById("quizContainer").style.display = "none";
        document.getElementById("errorScreen").style.display = "block";
        document.getElementById("errorMessage").textContent = errorMessage;
      }

      // Initialize Quiz (excludeQuestionId: optional ID to exclude when continuing)
      function initializeQuiz(excludeQuestionId) {
        if (!dataLoaded || allQuizData.length === 0) {
          showErrorScreen("No quiz data available");
          return;
        }

        // Select a random question, excluding the one just completed if provided
        let available = allQuizData;
        if (excludeQuestionId != null && allQuizData.length > 1) {
          available = allQuizData.filter((q) => q.id !== excludeQuestionId);
        }
        currentQuestion =
          available[Math.floor(Math.random() * available.length)];

        // Initialize session tracking
        sessionData.questionId = currentQuestion.id;
        sessionData.sessionStartTime = Date.now();
        quizData = [currentQuestion]; // For analytics compatibility

        console.log(`Starting quiz with question ID: ${currentQuestion.id}`);
        showQuestion();
      }

      // Show Question
      // Update Progress Bar
      function updateProgressBar() {
        const completed = 0; // Single question quiz - always 0 until complete
        const total = 1;
        const percentage = 0;
        
        const progressFill = document.getElementById("stageProgressFill");
        const progressText = document.getElementById("stageProgressText");
        
        if (progressFill && progressText) {
          progressFill.style.width = percentage + "%";
          progressText.textContent = completed + "/" + total;
        }
      }

      function showQuestion() {
        currentStep = "prepare";

        // Update progress bar
        updateProgressBar();

        // Reset UI
        resetUI();

        // Set photo
        document.getElementById("photoImage").src = currentQuestion.imageUrl;

        // Set initial state - preparation mode
        document.getElementById("questionTitle").textContent =
          "Prepare to speak about the image below";
        document.getElementById("questionSubtitle").textContent =
          "You will have 90 seconds to speak";
        document.getElementById("timerLabel").textContent = "to prepare";

        // Show record button, hide others
        document.getElementById("recordButton").style.display = "block";
        document.getElementById("audioVisualizer").style.display = "none";
        document.getElementById("continueBtn").style.display = "none";

        // Hide review section and results
        document.getElementById("reviewSection").style.display = "none";
        document.getElementById("resultsScreen").style.display = "none";
        document.getElementById("questionCard").style.display = "flex";

        // Start prepare timer
        startPrepareTimer();
      }

      function resetUI() {
        // Clear timers
        clearInterval(timerInterval);
        clearTimeout(prepareTimeout);
        clearTimeout(recordingTimeout);

        // Stop any playing audio
        stopAllAudio();

        // Reset record button
        const recordButton = document.getElementById("recordButton");
        recordButton.classList.remove("recording");
        recordButton.style.display = "block";

        // Hide audio visualizer and continue button initially
        document.getElementById("audioVisualizer").style.display = "none";
        document.getElementById("continueBtn").style.display = "none";

        // Reset timer
        document.getElementById("timer").classList.remove("warning");

        // Stop any recording
        if (mediaRecorder && mediaRecorder.state === "recording") {
          mediaRecorder.stop();
        }

        // Reset recorded data
        recordedChunks = [];
        recordedBlob = null;
      }

      function startPrepareTimer() {
        questionStartTime = Date.now();
        sessionData.preparationStartTime = Date.now();
        let seconds = 0;
        const maxSeconds = PREPARE_TIME / 1000; // 15 seconds

        timerInterval = setInterval(() => {
          seconds++;
          const minutes = Math.floor(seconds / 60);
          const remainingSeconds = seconds % 60;

          const timerElement = document.getElementById("timer");
          const timerText = document.getElementById("timerText");

          timerText.textContent = `${minutes}:${remainingSeconds
            .toString()
            .padStart(2, "0")}`;

          // Warning color after 10 seconds
          if (seconds >= 10) {
            timerElement.classList.add("warning");
          }

          if (seconds >= maxSeconds) {
            clearInterval(timerInterval);
            // Auto start recording after 15 seconds
            startRecording();
          }
        }, 1000);

        // Set timeout to auto-start recording after 15 seconds
        prepareTimeout = setTimeout(() => {
          startRecording();
        }, PREPARE_TIME);
      }

      async function startRecording() {
        currentStep = "speaking";

        // Record preparation time
        sessionData.preparationTime =
          Date.now() - sessionData.preparationStartTime;
        sessionData.speakingStartTime = Date.now();

        // Update UI for recording mode
        document.getElementById("questionTitle").textContent =
          "Speak about the image below";
        document.getElementById("questionSubtitle").textContent =
          "You have 90 seconds to speak";
        document.getElementById("recordButton").style.display = "none";
        document.getElementById("audioVisualizer").style.display = "flex";
        document.getElementById("continueBtn").style.display = "block";

        // Start recording timer
        startRecordingTimer();

        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
          mediaRecorder = new MediaRecorder(stream);
          recordedChunks = [];

          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              recordedChunks.push(event.data);
            }
          };

          mediaRecorder.onstop = () => {
            recordedBlob = new Blob(recordedChunks, { type: "audio/wav" });
            stream.getTracks().forEach((track) => track.stop());

            // Record speaking time
            sessionData.speakingTime =
              Date.now() - sessionData.speakingStartTime;
            sessionData.totalTime = Date.now() - sessionData.sessionStartTime;

            // Calculate time utilization
            const maxSpeakingTime = (quizConfig.speakingTime || 90) * 1000;
            sessionData.timeUtilized = Math.round(
              (sessionData.speakingTime / maxSpeakingTime) * 100
            );

            // Create answer object for analytics
            const answerData = {
              questionId: sessionData.questionId,
              preparationTime: sessionData.preparationTime,
              speakingTime: sessionData.speakingTime,
              totalTime: sessionData.totalTime,
              timeUtilized: sessionData.timeUtilized,
              sampleAnswer: currentQuestion.sampleAnswer,
            };

            answers = [answerData]; // Single answer array for analytics
          };

          mediaRecorder.start();
          console.log("Recording started");
        } catch (error) {
          console.error("Error starting recording:", error);
          alert("Could not access microphone. Please check permissions.");
        }
      }

      function startRecordingTimer() {
        let seconds = 0;
        const maxSeconds = quizConfig.speakingTime || 90; // Convert to seconds

        document.getElementById("timerLabel").textContent = "to speak";
        document.getElementById("timer").classList.remove("warning");

        timerInterval = setInterval(() => {
          seconds++;
          const minutes = Math.floor(seconds / 60);
          const remainingSeconds = seconds % 60;

          const timerElement = document.getElementById("timer");
          const timerText = document.getElementById("timerText");

          timerText.textContent = `${minutes}:${remainingSeconds
            .toString()
            .padStart(2, "0")}`;

          if (seconds >= maxSeconds) {
            clearInterval(timerInterval);
            stopRecording();
          }
        }, 1000);

        // Set timeout to auto-stop recording
        recordingTimeout = setTimeout(() => {
          stopRecording();
        }, (quizConfig.speakingTime || 90) * 1000);
      }

      function stopRecording() {
        if (mediaRecorder && mediaRecorder.state === "recording") {
          mediaRecorder.stop();
        }

        clearInterval(timerInterval);
        clearTimeout(recordingTimeout);

        // Hide audio visualizer
        document.getElementById("audioVisualizer").style.display = "none";

        console.log("Recording stopped");
      }
      // Calculate session metrics for single question
      function calculateSingleQuestionMetrics() {
        if (answers.length === 0) {
          return {
            totalTime: 0,
            avgTime: 0,
            consistency: 100,
            difficultyScore: 50,
            speakingFluency: 50,
            contentQuality: 50,
            timeUtilization: 0,
            preparationEfficiency: 50,
          };
        }

        const answer = answers[0];

        // Calculate speaking fluency
        const speakingTimeSeconds = answer.speakingTime / 1000;
        let speakingFluency = 50;

        if (speakingTimeSeconds >= 70 && speakingTimeSeconds <= 90) {
          speakingFluency = 90;
        } else if (speakingTimeSeconds >= 50 && speakingTimeSeconds < 70) {
          speakingFluency = 75;
        } else if (speakingTimeSeconds >= 30 && speakingTimeSeconds < 50) {
          speakingFluency = 60;
        }

        // Calculate content quality based on speaking time
        let contentQuality = 50;
        if (speakingTimeSeconds >= 60) {
          contentQuality = 80;
        } else if (speakingTimeSeconds >= 40) {
          contentQuality = 65;
        }

        // Calculate preparation efficiency
        const prepTimeSeconds = answer.preparationTime / 1000;
        let preparationEfficiency = 50;
        if (prepTimeSeconds >= 8 && prepTimeSeconds <= 12) {
          preparationEfficiency = 100;
        } else if (prepTimeSeconds >= 5 && prepTimeSeconds <= 15) {
          preparationEfficiency = 80;
        }

        return {
          totalTime: Math.round(answer.totalTime / 1000),
          avgTime: Math.round(answer.totalTime / 1000),
          consistency: 100, // Single question, perfect consistency
          difficultyScore: 75, // Default for single question
          speakingFluency: speakingFluency,
          contentQuality: contentQuality,
          timeUtilization: answer.timeUtilized,
          preparationEfficiency: preparationEfficiency,
        };
      }
      function handleRecord() {
        if (currentStep === "prepare") {
          // User clicked record button during preparation
          clearTimeout(prepareTimeout);
          clearInterval(timerInterval);
          startRecording();
        }
      }

      function nextStep() {
        if (currentStep === "speaking") {
          stopRecording();
          showReview();
        }
      }

      function showReview() {
        currentStep = "review";

        // Keep question card visible but hide the continue button
        document.getElementById("continueBtn").style.display = "none";

        // Hide audio visualizer since recording is done
        document.getElementById("audioVisualizer").style.display = "none";

        // Show review section
        document.getElementById("reviewSection").style.display = "block";
      }

      function stopAllAudio() {
        // Stop text-to-speech
        if (speechSynthesis) {
          speechSynthesis.cancel();
        }

        // Stop sample audio
        if (sampleAudio) {
          sampleAudio.pause();
          sampleAudio.currentTime = 0;
        }

        // Stop recording audio
        if (recordingAudio) {
          recordingAudio.pause();
          recordingAudio.currentTime = 0;
        }

        // Reset button states
        resetAudioButtons();

        isPlayingSample = false;
        isPlayingRecording = false;
      }

      function resetAudioButtons() {
        // Reset sample button
        const sampleBtn = document.getElementById("sampleBtn");
        const samplePlayIcon = document.getElementById("samplePlayIcon");
        const sampleStopIcon = document.getElementById("sampleStopIcon");
        const sampleBtnText = document.getElementById("sampleBtnText");

        if (sampleBtn) {
          sampleBtn.classList.remove("playing");
          samplePlayIcon.style.display = "block";
          sampleStopIcon.style.display = "none";
          sampleBtnText.textContent = "SAMPLE";
        }

        // Reset recording button
        const recordingBtn = document.getElementById("recordingBtn");
        const recordingPlayIcon = document.getElementById("recordingPlayIcon");
        const recordingStopIcon = document.getElementById("recordingStopIcon");
        const recordingBtnText = document.getElementById("recordingBtnText");

        if (recordingBtn) {
          recordingBtn.classList.remove("playing");
          recordingPlayIcon.style.display = "block";
          recordingStopIcon.style.display = "none";
          recordingBtnText.textContent = "YOUR RECORDING";
        }
      }

      function toggleSample() {
        if (isPlayingSample) {
          stopAllAudio();
        } else {
          stopAllAudio();
          playSample();
        }
      }

      function playSample() {
        if (!speechSynthesis) {
          alert("Text-to-speech is not supported in your browser");
          return;
        }

        try {
          isPlayingSample = true;

          // Update button appearance
          const sampleBtn = document.getElementById("sampleBtn");
          const samplePlayIcon = document.getElementById("samplePlayIcon");
          const sampleStopIcon = document.getElementById("sampleStopIcon");
          const sampleBtnText = document.getElementById("sampleBtnText");

          sampleBtn.classList.add("playing");
          samplePlayIcon.style.display = "none";
          sampleStopIcon.style.display = "block";
          sampleBtnText.textContent = "STOP";

          // Create utterance
          currentUtterance = new SpeechSynthesisUtterance(
            currentQuestion.sampleAnswer
          );

          // Configure speech
          currentUtterance.rate = 0.9;
          currentUtterance.pitch = 1.0;
          currentUtterance.volume = 0.8;

          // Try to use an English voice
          const voices = speechSynthesis.getVoices();
          const englishVoice =
            voices.find(
              (voice) =>
                voice.lang.startsWith("en") && !voice.name.includes("Google")
            ) || voices.find((voice) => voice.lang.startsWith("en"));

          if (englishVoice) {
            currentUtterance.voice = englishVoice;
          }

          // Handle speech end
          currentUtterance.onend = () => {
            isPlayingSample = false;
            resetAudioButtons();
          };

          currentUtterance.onerror = () => {
            isPlayingSample = false;
            resetAudioButtons();
          };

          // Speak the text
          speechSynthesis.speak(currentUtterance);
        } catch (error) {
          console.error("Error with text-to-speech:", error);
          alert("Error playing sample audio");
          isPlayingSample = false;
          resetAudioButtons();
        }
      }

      function toggleRecording() {
        if (isPlayingRecording) {
          stopAllAudio();
        } else {
          stopAllAudio();
          playRecording();
        }
      }

      function playRecording() {
        if (!recordedBlob) {
          alert("No recording available");
          return;
        }

        try {
          isPlayingRecording = true;

          // Update button appearance
          const recordingBtn = document.getElementById("recordingBtn");
          const recordingPlayIcon =
            document.getElementById("recordingPlayIcon");
          const recordingStopIcon =
            document.getElementById("recordingStopIcon");
          const recordingBtnText = document.getElementById("recordingBtnText");

          recordingBtn.classList.add("playing");
          recordingPlayIcon.style.display = "none";
          recordingStopIcon.style.display = "block";
          recordingBtnText.textContent = "STOP";

          const audioUrl = URL.createObjectURL(recordedBlob);
          recordingAudio = document.getElementById("recordingAudio");
          recordingAudio.src = audioUrl;

          recordingAudio.onended = () => {
            isPlayingRecording = false;
            resetAudioButtons();
            URL.revokeObjectURL(audioUrl);
          };

          recordingAudio.onerror = () => {
            isPlayingRecording = false;
            resetAudioButtons();
            URL.revokeObjectURL(audioUrl);
          };

          recordingAudio.play();
        } catch (error) {
          console.error("Error playing recording:", error);
          alert("Error playing your recording");
          isPlayingRecording = false;
          resetAudioButtons();
        }
      }

      function showResults() {
        stagesCompletedThisSession++;
        saveDetailedQuizResult("Speak About the Photo");

        stopAllAudio();
        document.getElementById("questionCard").style.display = "none";
        document.getElementById("reviewSection").style.display = "none";
        document.getElementById("resultsScreen").style.display = "block";
      }

      function continueToNextStage() {
        const completedId = currentQuestion?.id;
        resetUI();
        document.getElementById("resultsScreen").style.display = "none";
        document.getElementById("questionCard").style.display = "flex";
        initializeQuiz(completedId);
      }

      // Go to Practice Page
      function goToPractice() {
        stopAllAudio();
        incrementSkillProgress("Speak About the Photo", stagesCompletedThisSession);
        window.location.href = "index.html";
      }
      // Function to save detailed quiz result
      function saveDetailedQuizResult(skillName) {
        const sessionData = calculateSessionMetrics();

        // Create session result object
        const sessionResult = {
          skillName: skillName,
          sessionId: Date.now(),
          date: new Date().toISOString(),

          // Basic performance data
          totalQuestions: quizData.length,
          correctAnswers: quizData.length, // All speaking responses are considered "completed"
          accuracy: 100, // Speaking tasks are evaluated differently

          // Time analysis
          totalTimeSpent: sessionData.totalTime,
          averageTimePerQuestion: sessionData.avgTime,

          // Performance analysis for speaking
          consistency: sessionData.consistency,
          difficultyHandling: sessionData.difficultyScore,
          speakingFluency: sessionData.speakingFluency,
          contentQuality: sessionData.contentQuality,
          timeUtilization: sessionData.timeUtilization,
          preparationEfficiency: sessionData.preparationEfficiency,

          // Final session score
          sessionScore: calculateSessionScore(sessionData),

          // Individual question details
          questionDetails: answers.map((answer, index) => ({
            questionId: answer.questionId,
            questionType: "speak_about_photo",
            difficulty: determinePhotoDifficulty(quizData[index]),
            speakingTime: answer.speakingTime,
            preparationTime: answer.preparationTime,
            totalTime: answer.totalTime,
            timeUtilized: answer.timeUtilized,
            imageType: categorizeImageType(quizData[index]),
            sampleAnswer: answer.sampleAnswer,
            expectedElements: extractExpectedElements(
              quizData[index].sampleAnswer
            ),
          })),
        };

        // Save result to localStorage
        saveSessionToHistory(skillName, sessionResult);
        console.log(`Session saved for ${skillName}:`, sessionResult);
      }

      // Calculate session metrics specific to speaking tasks
      function calculateSessionMetrics() {
        return calculateSingleQuestionMetrics();
      }

      // Determine photo difficulty based on visual complexity
      function determinePhotoDifficulty(question) {
        let difficulty = 1; // Base difficulty (Easy)

        const imageUrl = question.imageUrl.toLowerCase();
        const sampleAnswer = question.sampleAnswer.toLowerCase();

        // Analyze sample answer complexity
        const sampleWords = question.sampleAnswer.split(" ").length;
        const sampleSentences = question.sampleAnswer
          .split(/[.!?]+/)
          .filter((s) => s.trim().length > 0).length;

        // Length-based complexity
        if (sampleWords > 80 || sampleSentences > 6) {
          difficulty += 1; // Complex descriptions
        } else if (sampleWords > 60 || sampleSentences > 4) {
          difficulty += 0.5; // Medium complexity
        }

        // Visual complexity indicators from sample answer
        const complexElements = [
          "multiple",
          "various",
          "different",
          "several",
          "many",
          "background",
          "foreground",
          "detail",
          "texture",
          "pattern",
        ];
        const hasComplexElements = complexElements.some((element) =>
          sampleAnswer.includes(element)
        );
        if (hasComplexElements) {
          difficulty += 0.5;
        }

        // Scene type complexity
        const sceneTypes = {
          nature: ["forest", "mountain", "tree", "landscape", "natural"],
          urban: ["building", "city", "street", "traffic", "urban"],
          people: ["person", "people", "group", "family", "individual"],
          indoor: ["room", "kitchen", "office", "indoor", "interior"],
          action: ["running", "walking", "working", "playing", "activity"],
        };

        // People and action scenes are typically more complex to describe
        if (
          sceneTypes.people.some((word) => sampleAnswer.includes(word)) ||
          sceneTypes.action.some((word) => sampleAnswer.includes(word))
        ) {
          difficulty += 0.5;
        }

        // Technical or specific vocabulary
        const technicalTerms = [
          "equipment",
          "professional",
          "technical",
          "specific",
          "particular",
        ];
        if (technicalTerms.some((term) => sampleAnswer.includes(term))) {
          difficulty += 0.3;
        }

        // Clamp difficulty between 1-3
        difficulty = Math.max(1, Math.min(3, difficulty));

        if (difficulty <= 1.5) return "easy";
        if (difficulty <= 2.5) return "medium";
        return "hard";
      }

      // Categorize image type for analysis
      function categorizeImageType(question) {
        const sampleAnswer = question.sampleAnswer.toLowerCase();

        if (
          sampleAnswer.includes("forest") ||
          sampleAnswer.includes("tree") ||
          sampleAnswer.includes("natural")
        ) {
          return "nature";
        } else if (
          sampleAnswer.includes("mountain") ||
          sampleAnswer.includes("landscape")
        ) {
          return "landscape";
        } else if (
          sampleAnswer.includes("building") ||
          sampleAnswer.includes("city")
        ) {
          return "urban";
        } else if (
          sampleAnswer.includes("people") ||
          sampleAnswer.includes("person")
        ) {
          return "people";
        } else if (
          sampleAnswer.includes("room") ||
          sampleAnswer.includes("indoor")
        ) {
          return "indoor";
        }

        return "general";
      }

      // Extract expected elements from sample answer
      function extractExpectedElements(sampleAnswer) {
        const elements = [];
        const words = sampleAnswer.toLowerCase().split(" ");

        // Key visual elements
        const visualElements = [
          "color",
          "light",
          "shadow",
          "texture",
          "size",
          "shape",
        ];
        const objectElements = [
          "tree",
          "building",
          "person",
          "car",
          "table",
          "chair",
        ];
        const descriptiveElements = [
          "beautiful",
          "large",
          "small",
          "bright",
          "dark",
          "clean",
        ];

        visualElements.forEach((element) => {
          if (words.includes(element)) elements.push(element);
        });

        objectElements.forEach((element) => {
          if (words.includes(element)) elements.push(element);
        });

        descriptiveElements.forEach((element) => {
          if (words.includes(element)) elements.push(element);
        });

        return elements;
      }

      // Calculate how well user handles different difficulty levels
      function calculateDifficultyHandling() {
        const difficultyStats = {
          easy: { responses: 0, totalTime: 0, avgUtilization: 0 },
          medium: { responses: 0, totalTime: 0, avgUtilization: 0 },
          hard: { responses: 0, totalTime: 0, avgUtilization: 0 },
        };

        // Analyze performance by difficulty
        answers.forEach((answer, index) => {
          const difficulty = determinePhotoDifficulty(quizData[index]);
          difficultyStats[difficulty].responses++;
          difficultyStats[difficulty].totalTime += answer.speakingTime;
          difficultyStats[difficulty].avgUtilization += answer.timeUtilized;
        });

        // Calculate weighted score based on difficulty handling
        let weightedScore = 0;
        let totalWeight = 0;

        Object.entries(difficultyStats).forEach(([difficulty, stats]) => {
          if (stats.responses > 0) {
            const avgTime = stats.totalTime / stats.responses;
            const avgUtilization = stats.avgUtilization / stats.responses;

            // Score based on appropriate time usage for difficulty level
            let difficultyScore = 50; // Base score

            // Time utilization bonus (using most of available time is good)
            if (avgUtilization > 70) {
              difficultyScore += 30;
            } else if (avgUtilization > 50) {
              difficultyScore += 20;
            } else if (avgUtilization > 30) {
              difficultyScore += 10;
            }

            // Consistency bonus for appropriate speaking time
            const expectedTime =
              difficulty === "easy"
                ? 60000
                : difficulty === "medium"
                ? 75000
                : 85000; // milliseconds
            if (Math.abs(avgTime - expectedTime) < expectedTime * 0.2) {
              difficultyScore += 20;
            }

            const weight =
              difficulty === "easy" ? 1 : difficulty === "medium" ? 1.5 : 2;
            weightedScore += difficultyScore * weight;
            totalWeight += weight;
          }
        });

        return totalWeight > 0 ? Math.round(weightedScore / totalWeight) : 0;
      }

      // Calculate speaking fluency based on time patterns
      function calculateSpeakingFluency() {
        let fluencyScore = 0;
        let validResponses = 0;

        answers.forEach((answer) => {
          validResponses++;
          let responseScore = 0;

          // Time utilization score (using 70-95% of available time is optimal)
          const utilization = answer.timeUtilized;
          if (utilization >= 70 && utilization <= 95) {
            responseScore += 40;
          } else if (utilization >= 50 && utilization < 70) {
            responseScore += 25;
          } else if (utilization > 95) {
            responseScore += 35; // Good but might be rushed at the end
          }

          // Consistency in speaking time (not too much variation)
          const speakingTimeSeconds = answer.speakingTime / 1000;
          if (speakingTimeSeconds >= 60 && speakingTimeSeconds <= 85) {
            responseScore += 30;
          } else if (speakingTimeSeconds >= 45 && speakingTimeSeconds <= 60) {
            responseScore += 20;
          }

          // Preparation vs speaking time balance
          const prepRatio =
            answer.preparationTime /
            (answer.preparationTime + answer.speakingTime);
          if (prepRatio >= 0.1 && prepRatio <= 0.2) {
            // 10-20% preparation time is good
            responseScore += 20;
          } else if (prepRatio >= 0.05 && prepRatio <= 0.25) {
            responseScore += 10;
          }

          // Timing efficiency (not running over time limits)
          if (answer.speakingTime <= 92000) {
            // Within 92 seconds (allowing small buffer)
            responseScore += 10;
          }

          fluencyScore += Math.min(responseScore, 100);
        });

        return validResponses > 0
          ? Math.round(fluencyScore / validResponses)
          : 0;
      }

      // Calculate estimated content quality based on speaking patterns
      function calculateContentQuality() {
        let qualityScore = 0;
        let validResponses = 0;

        answers.forEach((answer, index) => {
          validResponses++;
          let responseScore = 50; // Base score

          // Length appropriateness (longer speaking generally indicates more content)
          const speakingTimeSeconds = answer.speakingTime / 1000;
          if (speakingTimeSeconds >= 70 && speakingTimeSeconds <= 90) {
            responseScore += 25; // Optimal length
          } else if (speakingTimeSeconds >= 50 && speakingTimeSeconds < 70) {
            responseScore += 15; // Good length
          } else if (speakingTimeSeconds >= 30 && speakingTimeSeconds < 50) {
            responseScore += 5; // Short but acceptable
          }

          // Preparation time usage (good preparation usually leads to better content)
          const prepTimeSeconds = answer.preparationTime / 1000;
          if (prepTimeSeconds >= 8 && prepTimeSeconds <= 15) {
            responseScore += 15; // Good preparation time
          } else if (prepTimeSeconds >= 5 && prepTimeSeconds < 8) {
            responseScore += 10; // Some preparation
          }

          // Difficulty bonus (speaking well about complex images deserves more points)
          const difficulty = determinePhotoDifficulty(quizData[index]);
          if (difficulty === "hard" && speakingTimeSeconds >= 60) {
            responseScore += 10;
          } else if (difficulty === "medium" && speakingTimeSeconds >= 45) {
            responseScore += 5;
          }

          qualityScore += Math.min(responseScore, 100);
        });

        return validResponses > 0
          ? Math.round(qualityScore / validResponses)
          : 0;
      }

      // Calculate time utilization efficiency
      function calculateTimeUtilization() {
        const totalUtilization = answers.reduce(
          (sum, answer) => sum + answer.timeUtilized,
          0
        );
        return answers.length > 0
          ? Math.round(totalUtilization / answers.length)
          : 0;
      }

      // Calculate preparation efficiency
      function calculatePreparationEfficiency() {
        let efficiencyScore = 0;
        let validResponses = 0;

        answers.forEach((answer) => {
          validResponses++;
          const prepTime = answer.preparationTime / 1000; // Convert to seconds

          // Optimal preparation time is 8-12 seconds
          if (prepTime >= 8 && prepTime <= 12) {
            efficiencyScore += 100;
          } else if (prepTime >= 5 && prepTime <= 15) {
            efficiencyScore += 80;
          } else if (prepTime >= 3 && prepTime <= 18) {
            efficiencyScore += 60;
          } else {
            efficiencyScore += 40; // Too little or too much preparation
          }
        });

        return validResponses > 0
          ? Math.round(efficiencyScore / validResponses)
          : 0;
      }

      // Calculate final session score
      function calculateSessionScore(sessionData) {
        // Scoring weights for speaking tasks
        const weights = {
          speakingFluency: 0.3, // 30% - Most important for speaking
          contentQuality: 0.25, // 25% - Quality of content
          timeUtilization: 0.2, // 20% - Using available time well
          preparationEfficiency: 0.1, // 10% - Good preparation
          consistency: 0.1, // 10% - Consistent performance
          difficulty: 0.05, // 5% - Handling complex images
        };

        // Calculate final weighted score
        const finalScore =
          sessionData.speakingFluency * weights.speakingFluency +
          sessionData.contentQuality * weights.contentQuality +
          sessionData.timeUtilization * weights.timeUtilization +
          sessionData.preparationEfficiency * weights.preparationEfficiency +
          sessionData.consistency * weights.consistency +
          sessionData.difficultyScore * weights.difficulty;

        return Math.round(Math.max(0, Math.min(100, finalScore)));
      }

      // Save session to localStorage history
      function saveSessionToHistory(skillName, sessionResult) {
        const historyKey = `${skillName
          .replace(/\s+/g, "_")
          .toLowerCase()}_sessions`;

        try {
          // Get existing sessions
          const existingSessions = localStorage.getItem(historyKey);
          const sessions = existingSessions ? JSON.parse(existingSessions) : [];

          // Add new session
          sessions.push(sessionResult);

          // Keep only last 20 sessions to prevent storage overflow
          if (sessions.length > 20) {
            sessions.splice(0, sessions.length - 20);
          }

          // Save back to localStorage
          localStorage.setItem(historyKey, JSON.stringify(sessions));

          console.log(
            `Saved session to ${historyKey}. Total sessions: ${sessions.length}`
          );

          // Update overall skill assessment
          updateSkillOverallAssessment(skillName, sessions);
        } catch (error) {
          console.error("Error saving session to history:", error);
        }
      }

      // Update overall skill assessment based on all sessions
      function updateSkillOverallAssessment(skillName, allSessions) {
        if (!allSessions || allSessions.length === 0) return;

        // Calculate overall metrics for speaking
        const avgSpeakingFluency =
          allSessions.reduce(
            (sum, session) => sum + session.speakingFluency,
            0
          ) / allSessions.length;

        const avgContentQuality =
          allSessions.reduce(
            (sum, session) => sum + session.contentQuality,
            0
          ) / allSessions.length;

        const avgTimeUtilization =
          allSessions.reduce(
            (sum, session) => sum + session.timeUtilization,
            0
          ) / allSessions.length;

        // Calculate improvement (compare first vs last session)
        const firstSession = allSessions[0];
        const lastSession = allSessions[allSessions.length - 1];
        const improvement =
          lastSession.speakingFluency - firstSession.speakingFluency;

        // Calculate average session score
        const avgSessionScore =
          allSessions.reduce((sum, session) => sum + session.sessionScore, 0) /
          allSessions.length;

        // Calculate consistency across sessions
        const sessionScores = allSessions.map((s) => s.sessionScore);
        const scoreStdDev = calculateStandardDeviation(sessionScores);
        const crossSessionConsistency = Math.max(0, 100 - scoreStdDev);

        // Final skill score calculation
        const skillWeights = {
          speakingFluency: 0.35,
          contentQuality: 0.25,
          timeUtilization: 0.2,
          avgScore: 0.15,
          improvement: 0.05,
        };

        const normalizedImprovement = Math.max(
          0,
          Math.min(100, improvement + 50)
        ); // Normalize to 0-100

        const finalSkillScore =
          avgSpeakingFluency * skillWeights.speakingFluency +
          avgContentQuality * skillWeights.contentQuality +
          avgTimeUtilization * skillWeights.timeUtilization +
          avgSessionScore * skillWeights.avgScore +
          normalizedImprovement * skillWeights.improvement;

        // Create overall assessment
        const skillAssessment = {
          skillName: skillName,
          lastUpdated: new Date().toISOString(),
          sessionsCompleted: allSessions.length,

          // Performance metrics
          averageSpeakingFluency: Math.round(avgSpeakingFluency),
          averageContentQuality: Math.round(avgContentQuality),
          averageTimeUtilization: Math.round(avgTimeUtilization),
          averageSessionScore: Math.round(avgSessionScore),
          improvement: Math.round(improvement),
          consistency: Math.round(crossSessionConsistency),

          // Speaking-specific metrics
          averagePreparationEfficiency: Math.round(
            allSessions.reduce((sum, s) => sum + s.preparationEfficiency, 0) /
              allSessions.length
          ),
          averageSpeakingTime: Math.round(
            allSessions.reduce((sum, s) => sum + s.averageTimePerQuestion, 0) /
              allSessions.length
          ),

          // Final score
          finalScore: Math.round(finalSkillScore),
          level: determineSkillLevel(finalSkillScore),

          // Additional insights
          strongPoints: identifyStrongPoints(allSessions),
          weakPoints: identifyWeakPoints(allSessions),
          recommendations: generateRecommendations(
            allSessions,
            finalSkillScore
          ),
        };

        // Save overall assessment
        const assessmentKey = `${skillName
          .replace(/\s+/g, "_")
          .toLowerCase()}_assessment`;
        localStorage.setItem(assessmentKey, JSON.stringify(skillAssessment));

        console.log(
          `Updated overall assessment for ${skillName}:`,
          skillAssessment
        );
      }

      // Helper function to calculate standard deviation
      function calculateStandardDeviation(values) {
        const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
        const squaredDiffs = values.map((val) => Math.pow(val - mean, 2));
        const avgSquaredDiff =
          squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
        return Math.sqrt(avgSquaredDiff);
      }

      // Determine skill level based on final score
      function determineSkillLevel(score) {
        if (score >= 90) return "Advanced";
        if (score >= 75) return "Upper-Intermediate";
        if (score >= 60) return "Intermediate";
        if (score >= 45) return "Lower-Intermediate";
        if (score >= 30) return "Elementary";
        return "Beginner";
      }

      // Identify strong points from session data
      function identifyStrongPoints(sessions) {
        const strongPoints = [];

        // Check speaking fluency
        const avgSpeakingFluency =
          sessions.reduce((sum, s) => sum + s.speakingFluency, 0) /
          sessions.length;
        if (avgSpeakingFluency >= 80) {
          strongPoints.push("Excellent speaking fluency");
        }

        // Check content quality
        const avgContentQuality =
          sessions.reduce((sum, s) => sum + s.contentQuality, 0) /
          sessions.length;
        if (avgContentQuality >= 75) {
          strongPoints.push("High quality content in descriptions");
        }

        // Check time utilization
        const avgTimeUtilization =
          sessions.reduce((sum, s) => sum + s.timeUtilization, 0) /
          sessions.length;
        if (avgTimeUtilization >= 80) {
          strongPoints.push("Excellent time management");
        }

        // Check preparation efficiency
        const avgPrepEfficiency =
          sessions.reduce((sum, s) => sum + s.preparationEfficiency, 0) /
          sessions.length;
        if (avgPrepEfficiency >= 85) {
          strongPoints.push("Efficient preparation before speaking");
        }

        // Check consistency
        const sessionScores = sessions.map((s) => s.sessionScore);
        const scoreStdDev = calculateStandardDeviation(sessionScores);
        if (scoreStdDev <= 10) {
          strongPoints.push("Consistent performance across sessions");
        }

        return strongPoints.length > 0
          ? strongPoints
          : ["Shows improvement potential"];
      }

      // Identify weak points from session data
      function identifyWeakPoints(sessions) {
        const weakPoints = [];

        // Check speaking fluency
        const avgSpeakingFluency =
          sessions.reduce((sum, s) => sum + s.speakingFluency, 0) /
          sessions.length;
        if (avgSpeakingFluency < 60) {
          weakPoints.push("Speaking fluency needs improvement");
        }

        // Check content quality
        const avgContentQuality =
          sessions.reduce((sum, s) => sum + s.contentQuality, 0) /
          sessions.length;
        if (avgContentQuality < 65) {
          weakPoints.push("Focus on providing more detailed descriptions");
        }

        // Check time utilization
        const avgTimeUtilization =
          sessions.reduce((sum, s) => sum + s.timeUtilization, 0) /
          sessions.length;
        if (avgTimeUtilization < 60) {
          weakPoints.push("Try to use more of the available speaking time");
        } else if (avgTimeUtilization > 98) {
          weakPoints.push("Practice pacing to avoid rushing at the end");
        }

        // Check preparation efficiency
        const avgPrepEfficiency =
          sessions.reduce((sum, s) => sum + s.preparationEfficiency, 0) /
          sessions.length;
        if (avgPrepEfficiency < 70) {
          weakPoints.push("Improve preparation time management");
        }

        return weakPoints.length > 0
          ? weakPoints
          : ["Keep practicing to maintain progress"];
      }

      // Generate personalized recommendations
      function generateRecommendations(sessions, finalScore) {
        const recommendations = [];

        if (finalScore < 50) {
          recommendations.push("Practice describing simple images first");
          recommendations.push(
            "Use the full preparation time to organize thoughts"
          );
          recommendations.push("Focus on basic descriptive vocabulary");
        } else if (finalScore < 70) {
          recommendations.push("Work on speaking for the full time available");
          recommendations.push("Practice describing details and context");
          recommendations.push("Try to organize descriptions logically");
        } else if (finalScore < 85) {
          recommendations.push("Challenge yourself with complex images");
          recommendations.push("Practice advanced descriptive techniques");
          recommendations.push("Work on fluency and natural speech patterns");
        } else {
          recommendations.push(
            "Excellent work! Try describing abstract concepts"
          );
          recommendations.push("Practice with professional or artistic images");
          recommendations.push("Help others improve their speaking skills");
        }

        // Specific recommendations based on metrics
        const avgTimeUtilization =
          sessions.reduce((sum, s) => sum + s.timeUtilization, 0) /
          sessions.length;
        if (avgTimeUtilization < 70) {
          recommendations.push(
            "Practice speaking for the full 90 seconds available"
          );
        }

        const avgPrepEfficiency =
          sessions.reduce((sum, s) => sum + s.preparationEfficiency, 0) /
          sessions.length;
        if (avgPrepEfficiency < 75) {
          recommendations.push(
            "Use preparation time more effectively to plan your description"
          );
        }

        return recommendations;
      }
      // Function to increment progress by 1
      function incrementSkillProgress(skillName, count = 1) {
        // Get current progress first
        const currentProgress = getCurrentSkillProgress(skillName);
        const newCompleted = Math.min(currentProgress + count, 3); // Don't exceed 3

        const progressData = {
          skill: skillName,
          completed: newCompleted,
          total: 3,
          timestamp: new Date().toISOString(),
        };

        try {
          localStorage.setItem(
            "speakPhotoProgress",
            JSON.stringify(progressData)
          );
          console.log(`Progress updated: ${skillName} - ${newCompleted}/3`);
        } catch (error) {
          console.error("Error saving progress:", error);
        }
      }

      // Function to get current skill progress from localStorage
      function getCurrentSkillProgress(skillName) {
        try {
          // Check if there's existing progress in the main app
          const mainProgressData = localStorage.getItem("skillProgress");
          if (mainProgressData) {
            const allProgress = JSON.parse(mainProgressData);
            if (allProgress[skillName]) {
              return allProgress[skillName].completed || 0;
            }
          }
          return 0;
        } catch (error) {
          console.error("Error reading current progress:", error);
          return 0;
        }
      }

      function goBack() {
        if (confirm("Are you sure you want to exit the quiz?")) {
          if (stagesCompletedThisSession > 0) {
            incrementSkillProgress("Speak About the Photo", stagesCompletedThisSession);
          }
          stopAllAudio();
          window.history.back();
        }
      }

      // Keyboard Support
      document.addEventListener("keydown", function (event) {
        if (
          !dataLoaded ||
          document.getElementById("quizContainer").style.display === "none"
        ) {
          return;
        }

        if (event.key === "Escape") {
          goBack();
        }
      });

      // Handle page unload - stop all audio
      window.addEventListener("beforeunload", function () {
        stopAllAudio();
      });

      window.addEventListener("unload", function () {
        stopAllAudio();
      });

      // Initialize App on Load
      window.addEventListener("load", function () {
        console.log("Speak About the Photo Practice App loading...");

        // Wait for voices to load
        if (speechSynthesis.onvoiceschanged !== undefined) {
          speechSynthesis.onvoiceschanged = function () {
            console.log("Voices loaded:", speechSynthesis.getVoices().length);
          };
        }

        loadQuizData();
      });

      console.log(
        "Speak About the Photo Practice App initialized successfully!"
      );
    </script>
  </body>
</html>
