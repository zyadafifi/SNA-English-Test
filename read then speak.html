<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Read Then Speak - SNA English Test Practice</title>

    <!-- Resource Hints for Performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link rel="dns-prefetch" href="https://fonts.googleapis.com" />

    <!-- Preload Critical Assets -->
    <link
      rel="prefetch"
      href="read then speak data.json"
      as="fetch"
      type="application/json"
    />

    <!-- Optimized Font Loading -->
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
      rel="stylesheet"
      media="print"
      onload="this.media='all'"
    />
    <noscript>
      <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
        rel="stylesheet"
      />
    </noscript>
    <link rel="stylesheet" href="background.css" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, sans-serif;
        background-color: #f8f9fa;
        min-height: 100vh;
        line-height: 1.6;
        color: #334155;
      }

      /* Loading Screen */
      .loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #f8f9fa;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      .loading-screen > div {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 20px;
      }

      .loading-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #e0e0e0;
        border-top: 4px solid #ffc515;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        flex-shrink: 0;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .loading-text {
        font-size: 16px;
        color: #6b7280;
        text-align: center;
        margin: 0;
      }

      /* Error Screen */
      .error-screen {
        display: none;
        text-align: center;
        padding: 40px;
        background-color: #ffebee;
        border-radius: 12px;
        border: 1px solid #f44336;
        margin: 20px;
      }

      .error-title {
        font-size: 24px;
        font-weight: 600;
        color: #f44336;
        margin-bottom: 10px;
      }

      .error-message {
        color: #6b7280;
        margin-bottom: 20px;
      }

      .retry-data-btn {
        background: #ffc515;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s;
      }

      .retry-data-btn:hover {
        background: #ffb300;
      }

      /* Quiz Container */
      .quiz-container {
        max-width: 100%;
        margin: 0 auto;
        padding: 40px;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: transparent;
      }

      /* Question Card */
      .question-card {
        background: white;
        border-radius: 12px 12px 0 0;
        padding: 50px 60px;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
        width: 100%;
        max-width: 1200px;
        text-align: center;
        position: relative;
        min-height: 600px;
        display: flex;
        margin: 0 auto;
        margin-bottom: 0;
        box-sizing: border-box;
        flex-direction: column;
        justify-content: center;
      }

      /* Timer */
      .timer {
        position: absolute;
        top: 30px;
        left: 30px;
        background: transparent;
        padding: 0;
        border-radius: 0;
        font-weight: 400;
        color: #888;
        font-size: 16px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .timer-icon {
        width: 20px;
        height: 20px;
        fill: currentColor;
      }

      .timer.warning {
        color: #f44336;
        font-weight: 600;
      }

      /* Close Button */
      .close-btn {
        position: absolute;
        top: 25px;
        right: 25px;
        background: none;
        border: none;
        cursor: pointer;
        padding: 8px;
        border-radius: 4px;
        transition: background 0.2s;
        color: #ddd;
      }

      .close-btn:hover {
        background: #f8f8f8;
      }

      /* Progress Bar */
      .stage-progress-bar {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 30px;
        width: 100%;
        max-width: 400px;
        margin-left: auto;
        margin-right: auto;
      }

      .progress-track {
        flex: 1;
        height: 8px;
        background: #e0e0e0;
        border-radius: 4px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        background: #ffc515;
        border-radius: 4px;
        transition: width 0.3s ease;
        width: 0%;
      }

      .progress-text {
        font-size: 14px;
        color: #666;
        font-weight: 500;
        min-width: 45px;
        text-align: right;
      }

      /* Question Content */
      .question-title {
        font-size: 28px;
        font-weight: 400;
        color: #6b7280;
        margin-bottom: 20px;
        line-height: 1.2;
      }

      .question-subtitle {
        font-size: 16px;
        color: #888;
        margin-bottom: 40px;
      }

      /* Topic Container */
      .topic-container {
        margin-bottom: 40px;
        padding: 30px;
        background: #f8f9fa;
        border-radius: 12px;
        border: 2px solid #e9ecef;
        text-align: left;
        max-width: 100%;
        width: 100%;
        margin-left: auto;
        margin-right: auto;
        box-sizing: border-box;
      }

      .topic-text {
        font-size: 16px;
        color: #495057;
        line-height: 1.7;
        margin-bottom: 20px;
        font-weight: 500;
        word-wrap: break-word;
        hyphens: auto;
      }

      .topic-questions {
        list-style: none;
        padding: 0;
        margin: 0;
      }

      .topic-questions li {
        font-size: 14px;
        color: #6c757d;
        margin-bottom: 12px;
        padding-left: 20px;
        position: relative;
        line-height: 1.6;
        word-wrap: break-word;
        hyphens: auto;
      }

      .topic-questions li:before {
        content: "â€¢";
        color: #6c757d;
        position: absolute;
        left: 0;
        font-weight: bold;
        top: 0;
      }

      /* Record Button */
      .record-button {
        background: #ffc515;
        color: white;
        border: none;
        padding: 16px 32px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s;
        text-transform: uppercase;
        letter-spacing: 1px;
        display: flex;
        align-items: center;
        gap: 8px;
        justify-content: center;
        margin: 0 auto;
        min-width: 180px;
        white-space: nowrap;
      }

      .record-button:hover {
        background: #ffb300;
        transform: translateY(-2px);
      }

      .record-button.recording {
        background: #f44336;
        animation: pulse 1.5s infinite;
      }

      @keyframes pulse {
        0% {
          box-shadow: 0 4px 20px rgba(244, 67, 54, 0.3);
        }
        50% {
          box-shadow: 0 4px 30px rgba(244, 67, 54, 0.6);
        }
        100% {
          box-shadow: 0 4px 20px rgba(244, 67, 54, 0.3);
        }
      }

      .record-icon {
        width: 20px;
        height: 20px;
        fill: currentColor;
        flex-shrink: 0;
      }

      /* Recording Status */
      .recording-status {
        display: none;
        align-items: center;
        justify-content: center;
        gap: 12px;
        margin: 20px 0;
        color: #ffc515;
        font-size: 16px;
        font-weight: 600;
        flex-wrap: wrap;
      }

      .recording-dot {
        width: 8px;
        height: 8px;
        background: #ffc515;
        border-radius: 50%;
        animation: blink 1s infinite;
      }

      @keyframes blink {
        0%,
        50% {
          opacity: 1;
        }
        51%,
        100% {
          opacity: 0.3;
        }
      }

      /* Audio Visualization */
      .audio-visualizer {
        margin: 20px 0;
        display: none;
        justify-content: center;
        align-items: center;
        gap: 3px;
        flex-wrap: wrap;
        overflow: hidden;
      }

      .audio-bar {
        width: 4px;
        background: #ffc515;
        border-radius: 2px;
        animation: audioWave 1s ease-in-out infinite;
        min-height: 15px;
      }

      .audio-bar:nth-child(1) {
        height: 20px;
        animation-delay: 0s;
      }
      .audio-bar:nth-child(2) {
        height: 30px;
        animation-delay: 0.1s;
      }
      .audio-bar:nth-child(3) {
        height: 25px;
        animation-delay: 0.2s;
      }
      .audio-bar:nth-child(4) {
        height: 35px;
        animation-delay: 0.3s;
      }
      .audio-bar:nth-child(5) {
        height: 20px;
        animation-delay: 0.4s;
      }
      .audio-bar:nth-child(6) {
        height: 30px;
        animation-delay: 0.5s;
      }
      .audio-bar:nth-child(7) {
        height: 25px;
        animation-delay: 0.6s;
      }
      .audio-bar:nth-child(8) {
        height: 30px;
        animation-delay: 0.7s;
      }
      .audio-bar:nth-child(9) {
        height: 20px;
        animation-delay: 0.8s;
      }
      .audio-bar:nth-child(10) {
        height: 25px;
        animation-delay: 0.9s;
      }
      .audio-bar:nth-child(11) {
        height: 35px;
        animation-delay: 1s;
      }
      .audio-bar:nth-child(12) {
        height: 20px;
        animation-delay: 1.1s;
      }
      .audio-bar:nth-child(13) {
        height: 30px;
        animation-delay: 1.2s;
      }
      .audio-bar:nth-child(14) {
        height: 25px;
        animation-delay: 1.3s;
      }
      .audio-bar:nth-child(15) {
        height: 20px;
        animation-delay: 1.4s;
      }

      @keyframes audioWave {
        0%,
        100% {
          transform: scaleY(1);
        }
        50% {
          transform: scaleY(0.5);
        }
      }

      /* Continue Button */
      .continue-btn {
        background: #ffc515;
        color: white;
        border: none;
        padding: 14px 28px;
        border-radius: 9999px;
        font-size: 16px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s;
        text-transform: uppercase;
        letter-spacing: 1px;
        position: absolute;
        bottom: 30px;
        right: 30px;
      }

      .continue-btn:hover {
        background: #ffb300;
      }

      .continue-btn:disabled {
        background: #e0e0e0;
        color: #999;
        cursor: not-allowed;
      }

      /* Review Section */
      .review-section {
        background: #ffe8b0;
        border-radius: 12px;
        padding: 28px 40px 80px 40px;
        margin: 20px auto 0 auto;
        border: none;
        display: none;
        position: relative;
        width: 100%;
        max-width: 900px;
        box-sizing: border-box;
        text-align: left;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
      }

      .review-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 16px;
      }

      .review-icon {
        width: 20px;
        height: 20px;
        flex-shrink: 0;
        fill: #2e7d32;
      }

      .review-title {
        font-size: 16px;
        font-weight: 700;
        margin: 0;
        color: #2e7d32;
      }

      .review-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-top: 16px;
        justify-content: flex-start;
      }

      .sample-btn,
      .recording-btn {
        background: white;
        color: #ffc515;
        border: 2px solid #ffc515;
        padding: 10px 18px;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 6px;
        white-space: nowrap;
        min-width: 120px;
        justify-content: center;
      }

      .sample-btn:hover,
      .recording-btn:hover {
        background: #ffc515;
        color: white;
      }

      .sample-btn.playing,
      .recording-btn.playing {
        background: #f44336;
        border-color: #f44336;
        color: white;
      }

      .play-icon,
      .stop-icon {
        width: 14px;
        height: 14px;
        fill: currentColor;
      }

      /* Continue Button in Review */
      .continue-review-btn {
        background: #ffc515;
        color: white;
        border: none;
        padding: 14px 24px;
        border-radius: 9999px;
        font-size: 14px;
        font-weight: 700;
        cursor: pointer;
        transition: background 0.2s;
        text-transform: uppercase;
        letter-spacing: 1px;
        position: absolute;
        bottom: 24px;
        right: 24px;
      }

      .continue-review-btn:hover {
        background: #ffb300;
      }

      /* Results Screen */
      .results-screen {
        display: none;
        text-align: center;
        background: white;
        border-radius: 12px;
        padding: 80px 60px;
        box-shadow: 0 4px 24px rgba(0, 0, 0, 0.08);
        width: 100%;
        max-width: 600px;
        min-height: 400px;
        position: relative;
      }

      .results-icon {
        width: 80px;
        height: 80px;
        margin: 0 auto 40px;
        background: #ffc515;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }

      .results-icon svg {
        width: 40px;
        height: 40px;
        fill: white;
      }

      .results-title {
        font-size: 24px;
        font-weight: 500;
        color: #777;
        margin-bottom: 10px;
        line-height: 1.3;
      }

      .results-subtitle {
        font-size: 18px;
        font-weight: 400;
        color: #777;
        margin-bottom: 60px;
      }

      .results-buttons {
        display: flex;
        flex-direction: row;
        gap: 16px;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        margin-top: 40px;
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
      }

      .results-buttons .results-continue-btn,
      .results-buttons .done-btn {
        position: static;
        bottom: auto;
        right: auto;
        left: auto;
      }

      .results-continue-btn {
        background: white;
        color: #ffc515;
        border: 2px solid #ffc515;
        padding: 14px 28px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .results-continue-btn:hover {
        background: #fff8e1;
      }

      .done-btn {
        background: #ffc515;
        color: white;
        border: none;
        padding: 14px 28px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 700;
        cursor: pointer;
        transition: background 0.2s;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .done-btn:hover {
        background: #ffb300;
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        .quiz-container {
          padding: 15px;
        }

        .question-card {
          padding: 30px 25px;
          min-height: 500px;
          max-width: 100%;
          border-radius: 12px 12px 0 0;
        }

        .question-title {
          font-size: 22px;
          margin-bottom: 16px;
          line-height: 1.3;
        }

        .question-subtitle {
          font-size: 15px;
          margin-bottom: 30px;
        }

        /* Topic container for tablets */
        .topic-container {
          padding: 25px;
          margin-bottom: 30px;
          max-width: 100%;
          border-radius: 10px;
        }

        .topic-text {
          font-size: 15px;
          line-height: 1.6;
          margin-bottom: 18px;
        }

        .topic-questions li {
          font-size: 13px;
          margin-bottom: 10px;
          padding-left: 18px;
        }

        /* Record button for tablets */
        .record-button {
          padding: 14px 28px;
          font-size: 15px;
          min-width: 160px;
          gap: 6px;
        }

        .record-icon {
          width: 18px;
          height: 18px;
        }

        /* Recording status for tablets */
        .recording-status {
          font-size: 15px;
          margin: 18px 0;
          gap: 10px;
        }

        /* Audio visualizer for tablets */
        .audio-visualizer {
          margin: 18px 0;
          gap: 2px;
        }

        .audio-bar {
          width: 3px;
        }

        /* Review section for tablets */
        .review-section {
          padding: 24px 25px 75px 25px;
          margin: 15px auto 0 auto;
          border-radius: 10px;
        }

        .review-buttons {
          gap: 10px;
          justify-content: center;
        }

        .sample-btn,
        .recording-btn {
          padding: 9px 16px;
          font-size: 13px;
          min-width: 110px;
        }

        /* Button positioning for tablets */
        .continue-btn,
        .continue-review-btn,
        .done-btn {
          bottom: 20px;
          right: 20px;
          padding: 12px 24px;
          font-size: 14px;
        }

        .timer {
          top: 20px;
          left: 20px;
          font-size: 14px;
        }

        .close-btn {
          top: 15px;
          right: 15px;
        }
      }

      @media (max-width: 480px) {
        .quiz-container {
          padding: 10px;
        }

        .question-card {
          padding: 25px 20px;
          min-height: 450px;
          border-radius: 12px 12px 0 0;
        }

        .question-title {
          font-size: 20px;
          margin-bottom: 14px;
          line-height: 1.2;
        }

        .question-subtitle {
          font-size: 14px;
          margin-bottom: 25px;
        }

        /* Topic container for mobile */
        .topic-container {
          padding: 20px 18px;
          margin-bottom: 25px;
          border-radius: 8px;
          border-width: 1px;
        }

        .topic-text {
          font-size: 14px;
          line-height: 1.6;
          margin-bottom: 16px;
          font-weight: 500;
        }

        .topic-questions {
          margin: 0;
        }

        .topic-questions li {
          font-size: 12px;
          margin-bottom: 10px;
          padding-left: 16px;
          line-height: 1.5;
        }

        .topic-questions li:before {
          font-size: 12px;
        }

        /* Record button for mobile */
        .record-button {
          padding: 12px 24px;
          font-size: 14px;
          min-width: 140px;
          gap: 4px;
        }

        .record-icon {
          width: 16px;
          height: 16px;
        }

        /* Recording status for mobile */
        .recording-status {
          font-size: 14px;
          margin: 16px 0;
          gap: 8px;
        }

        .recording-dot {
          width: 6px;
          height: 6px;
        }

        /* Audio visualizer for mobile */
        .audio-visualizer {
          margin: 16px 0;
          gap: 2px;
        }

        .audio-bar {
          width: 2px;
        }

        .audio-bar:nth-child(1) {
          height: 16px;
        }
        .audio-bar:nth-child(2) {
          height: 24px;
        }
        .audio-bar:nth-child(3) {
          height: 20px;
        }
        .audio-bar:nth-child(4) {
          height: 28px;
        }
        .audio-bar:nth-child(5) {
          height: 16px;
        }
        .audio-bar:nth-child(6) {
          height: 24px;
        }
        .audio-bar:nth-child(7) {
          height: 20px;
        }
        .audio-bar:nth-child(8) {
          height: 24px;
        }
        .audio-bar:nth-child(9) {
          height: 16px;
        }
        .audio-bar:nth-child(10) {
          height: 20px;
        }
        .audio-bar:nth-child(11) {
          height: 28px;
        }
        .audio-bar:nth-child(12) {
          height: 16px;
        }
        .audio-bar:nth-child(13) {
          height: 24px;
        }
        .audio-bar:nth-child(14) {
          height: 20px;
        }
        .audio-bar:nth-child(15) {
          height: 16px;
        }

        /* Review section for mobile */
        .review-section {
          padding: 20px 18px 70px 18px;
          margin: 12px 8px 0 8px;
          border-radius: 8px;
        }

        .review-header {
          gap: 8px;
          margin-bottom: 14px;
        }

        .review-icon {
          width: 18px;
          height: 18px;
        }

        .review-title {
          font-size: 15px;
        }

        .review-buttons {
          gap: 8px;
          flex-direction: column;
          align-items: stretch;
        }

        .sample-btn,
        .recording-btn {
          padding: 12px 16px;
          font-size: 13px;
          min-width: auto;
          width: 100%;
          justify-content: center;
        }

        .play-icon,
        .stop-icon {
          width: 12px;
          height: 12px;
        }

        /* Button positioning for mobile */
        .continue-btn,
        .done-btn {
          bottom: 18px;
          right: 18px;
          left: 18px;
          width: calc(100% - 36px);
          padding: 14px 20px;
          font-size: 14px;
          text-align: center;
        }

        .continue-review-btn {
          position: relative;
          bottom: auto;
          right: auto;
          left: auto;
          width: 100%;
          margin: 20px 0 0 0;
          padding: 14px 20px;
          font-size: 14px;
        }

        .timer {
          top: 18px;
          left: 18px;
          font-size: 13px;
        }

        .timer-icon {
          width: 16px;
          height: 16px;
        }

        .close-btn {
          top: 12px;
          right: 12px;
          padding: 6px;
        }

        .close-btn svg {
          width: 16px;
          height: 16px;
        }

        /* Results screen for mobile */
        .results-screen {
          padding: 40px 25px;
          margin: 10px;
        }

        .results-icon {
          width: 60px;
          height: 60px;
          margin-bottom: 30px;
        }

        .results-icon svg {
          width: 30px;
          height: 30px;
        }

        .results-title {
          font-size: 20px;
          margin-bottom: 8px;
        }

        .results-subtitle {
          font-size: 16px;
          margin-bottom: 40px;
        }

        .stage-progress-bar {
          gap: 8px;
          max-width: 100%;
          margin-bottom: 20px;
        }

        .progress-track {
          height: 6px;
        }

        .progress-text {
          font-size: 12px;
          min-width: 35px;
        }

        .loading-spinner {
          width: 32px;
          height: 32px;
          border-width: 3px;
        }

        .loading-screen > div {
          gap: 16px;
        }

        .loading-text {
          font-size: 14px;
        }
      }
    </style>
  </head>
  <body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
      <div>
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading quiz data...</div>
      </div>
    </div>

    <!-- Error Screen -->
    <div class="error-screen" id="errorScreen">
      <div class="error-title">Failed to Load Quiz Data</div>
      <div class="error-message" id="errorMessage">
        Could not load the quiz questions. Please check your internet connection
        and try again.
      </div>
      <button class="retry-data-btn" onclick="loadQuizData()">Retry</button>
      <button
        class="retry-data-btn"
        onclick="goBack()"
        style="background: #f0f0f0; color: #666; margin-left: 10px"
      >
        Go Back
      </button>
    </div>

    <div class="quiz-container" id="quizContainer" style="display: none">
      <!-- Question Card -->
      <div class="question-card" id="questionCard">
        <!-- Timer -->
        <div class="timer" id="timer">
          <svg
            class="timer-icon"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <circle cx="12" cy="12" r="10" />
            <polyline points="12,6 12,12 16,14" />
          </svg>
          <span id="timerText">0:16</span>
          <span style="color: #999; margin-left: 6px" id="timerLabel"
            >to prepare</span
          >
        </div>

        <!-- Close Button -->
        <button class="close-btn" onclick="goBack()">
          <svg
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>

        <!-- Progress Bar -->
        <div class="stage-progress-bar">
          <div class="progress-track">
            <div class="progress-fill" id="stageProgressFill"></div>
          </div>
          <span class="progress-text" id="stageProgressText">0/3</span>
        </div>

        <!-- Question Content -->
        <div class="question-content" id="questionContent">
          <h1 class="question-title" id="questionTitle">
            Prepare to speak about the topic below
          </h1>

          <p class="question-subtitle" id="questionSubtitle">
            You will have 90 seconds to speak
          </p>

          <!-- Topic Container -->
          <div class="topic-container">
            <div class="topic-text" id="topicText">
              Discuss a school subject that you think should be required for all
              high school students.
            </div>
            <ul class="topic-questions" id="topicQuestions">
              <li>What is this subject?</li>
              <li>
                Why do you think it should be required for high school students?
              </li>
            </ul>
          </div>

          <!-- Record Button -->
          <button
            class="record-button"
            id="recordButton"
            onclick="handleRecord()"
          >
            <span class="mic-icon"
              ><svg
                height="24"
                preserveAspectRatio="xMidYMin slice"
                width="24"
                style="color: rgb(var(--color-snow)); overflow: visible"
                viewBox="0 0 24 24"
              >
                <path
                  fill-rule="evenodd"
                  clip-rule="evenodd"
                  d="M11.5055 0.921631C9.29632 0.921631 7.50546 2.71249 7.50546 4.92163V10.5029C7.50546 12.712 9.29632 14.5029 11.5055 14.5029H12.4973C14.7065 14.5029 16.4973 12.712 16.4973 10.5029V4.92163C16.4973 2.71249 14.7065 0.921631 12.4973 0.921631H11.5055ZM19.9809 12.4921C19.9809 11.9398 19.5332 11.4921 18.9809 11.4921C18.4286 11.4921 17.9809 11.9398 17.9809 12.4921C17.9809 14.924 16.0058 16.8983 13.566 16.8983H10.3052C7.93658 16.8983 6.01913 14.9816 6.01913 12.6206C6.01913 12.0683 5.57141 11.6206 5.01913 11.6206C4.46684 11.6206 4.01913 12.0683 4.01913 12.6206C4.01913 16.0892 6.83503 18.8983 10.3052 18.8983H10.9789V21.0783H10.2096C9.65732 21.0783 9.2096 21.526 9.2096 22.0783C9.2096 22.6305 9.65732 23.0783 10.2096 23.0783H13.9125C14.4648 23.0783 14.9125 22.6305 14.9125 22.0783C14.9125 21.526 14.4648 21.0783 13.9125 21.0783H12.9789V18.8983H13.566C17.1073 18.8983 19.9809 16.0316 19.9809 12.4921Z"
                  fill="currentcolor"
                ></path></svg
            ></span>
            <span id="recordButtonText">RECORD NOW</span>
          </button>

          <!-- Recording Status -->
          <div class="recording-status" id="recordingStatus">
            <div class="recording-dot"></div>
            <span>RECORDING...</span>
          </div>

          <!-- Audio Visualizer -->
          <div class="audio-visualizer" id="audioVisualizer">
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
          </div>

          <!-- Continue Button -->
          <button class="continue-btn" id="continueBtn" onclick="nextStep()">
            CONTINUE
          </button>
        </div>
      </div>

      <!-- Review Section -->
      <div class="review-section" id="reviewSection">
        <div class="review-header">
          <svg
            class="review-icon"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <circle cx="12" cy="12" r="10" />
            <polyline points="16,8 10,14 8,12" />
          </svg>
          <div class="review-title">Review sample answer:</div>
        </div>

        <div class="review-buttons">
          <button class="sample-btn" id="sampleBtn" onclick="toggleSample()">
            <svg class="play-icon" id="samplePlayIcon" viewBox="0 0 24 24">
              <polygon points="5,3 19,12 5,21"></polygon>
            </svg>
            <svg
              class="stop-icon"
              id="sampleStopIcon"
              viewBox="0 0 24 24"
              style="display: none"
            >
              <rect x="6" y="4" width="4" height="16"></rect>
              <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
            <span id="sampleBtnText">SAMPLE</span>
          </button>
          <button
            class="recording-btn"
            id="recordingBtn"
            onclick="toggleRecording()"
          >
            <svg class="play-icon" id="recordingPlayIcon" viewBox="0 0 24 24">
              <polygon points="5,3 19,12 5,21"></polygon>
            </svg>
            <svg
              class="stop-icon"
              id="recordingStopIcon"
              viewBox="0 0 24 24"
              style="display: none"
            >
              <rect x="6" y="4" width="4" height="16"></rect>
              <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
            <span id="recordingBtnText">YOUR RECORDING</span>
          </button>
        </div>

        <button class="continue-review-btn" onclick="showResults()">
          CONTINUE
        </button>
      </div>

      <!-- Results Screen -->
      <div class="results-screen" id="resultsScreen">
        <div class="results-icon">
          <svg viewBox="0 0 24 24">
            <path d="M8 5V19L19 12L8 5Z" />
          </svg>
        </div>
        <div class="results-title">Practice complete! You</div>
        <div class="results-subtitle">improved your speaking skills.</div>
        <div class="results-buttons">
          <button class="results-continue-btn" onclick="continueToNextStage()">CONTINUE</button>
          <button class="done-btn" onclick="goToPractice()">DONE</button>
        </div>
      </div>
    </div>

    <!-- Hidden Audio Elements -->
    <audio id="sampleAudio" preload="auto"></audio>
    <audio id="recordingAudio" preload="auto"></audio>

    <script src="skills-config.js"></script>
    <script>
      // Quiz Data (will be loaded from JSON)
      let allQuizData = [];
      let quizConfig = {};

      // Quiz State
      let currentQuestion = null;
      let currentStep = "prepare"; // prepare, speaking, review, results
      let questionStartTime = 0;
      let timerInterval;
      let prepareTimeout;
      let recordingTimeout;
      let mediaRecorder;
      let recordedChunks = [];
      let recordedBlob = null;
      let speechSynthesis = window.speechSynthesis;
      let currentUtterance = null;
      let sampleAudio = null;
      let recordingAudio = null;
      let isPlayingSample = false;
      let isPlayingRecording = false;
      let dataLoaded = false;
      let stagesCompletedThisSession = 0;
      // Session tracking variables
      let sessionStartTime = Date.now();
      let answers = []; // Array to store all responses
      let currentQuestionData = null; // Current question being answered

      // Response timing variables
      let questionPrepStartTime = 0;
      let questionSpeakStartTime = 0;
      let actualPreparationTime = 0;
      let actualSpeakingTime = 0;
      // Configuration
      const PREPARE_TIME = 15000; // 15 seconds preparation time
      const RECORDING_TIME = 90000; // Will be loaded from JSON

      // Load Quiz Data from JSON
      async function loadQuizData() {
        try {
          showLoadingScreen();

          const response = await fetch("read then speak data.json");
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();

          // Validate data structure
          if (
            !data.questions ||
            !Array.isArray(data.questions) ||
            data.questions.length === 0
          ) {
            throw new Error(
              "Invalid data format: questions array is missing or empty"
            );
          }

          allQuizData = data.questions;
          quizConfig = data.config || {};

          if (allQuizData.length === 0) {
            throw new Error("No questions available in the data file.");
          }

          dataLoaded = true;
          hideLoadingScreen();
          initializeQuiz();
        } catch (error) {
          console.error("Error loading quiz data:", error);
          showErrorScreen(error.message);
        }
      }

      // Show/Hide Loading Screen
      function showLoadingScreen() {
        document.getElementById("loadingScreen").style.display = "flex";
        document.getElementById("errorScreen").style.display = "none";
        document.getElementById("quizContainer").style.display = "none";
      }

      function hideLoadingScreen() {
        document.getElementById("loadingScreen").style.display = "none";
        document.getElementById("quizContainer").style.display = "flex";
      }

      function showErrorScreen(errorMessage) {
        document.getElementById("loadingScreen").style.display = "none";
        document.getElementById("quizContainer").style.display = "none";
        document.getElementById("errorScreen").style.display = "block";
        document.getElementById("errorMessage").textContent = errorMessage;
      }

      // Initialize Quiz (excludeQuestionId: optional ID to exclude when continuing)
      function initializeQuiz(excludeQuestionId) {
        if (!dataLoaded || allQuizData.length === 0) {
          showErrorScreen("No quiz data available");
          return;
        }

        // Initialize session tracking
        sessionStartTime = Date.now();
        answers = [];

        // Select a random question, excluding the one just completed if provided
        let available = allQuizData;
        if (excludeQuestionId != null && allQuizData.length > 1) {
          available = allQuizData.filter((q) => q.id !== excludeQuestionId);
        }
        currentQuestion =
          available[Math.floor(Math.random() * available.length)];

        console.log(`Starting quiz with question ID: ${currentQuestion.id}`);
        showQuestion();
      }

      // Show Question
      // Update Progress Bar
      function updateProgressBar() {
        const completed = 0; // Single question quiz - always 0 until complete
        const total = 1;
        const percentage = 0;
        
        const progressFill = document.getElementById("stageProgressFill");
        const progressText = document.getElementById("stageProgressText");
        
        if (progressFill && progressText) {
          progressFill.style.width = percentage + "%";
          progressText.textContent = completed + "/" + total;
        }
      }

      function showQuestion() {
        currentStep = "prepare";

        // Update progress bar
        updateProgressBar();

        // Initialize question data tracking
        currentQuestionData = {
          questionId: currentQuestion.id,
          topicText: currentQuestion.topicText,
          topicQuestions: currentQuestion.topicQuestions,
          sampleAnswer: currentQuestion.sampleAnswer,
          startTime: Date.now(),
          preparationStartTime: Date.now(),
        };

        // Reset timing variables
        questionPrepStartTime = Date.now();
        actualPreparationTime = 0;
        actualSpeakingTime = 0;

        // Reset UI
        resetUI();

        // Set topic content
        document.getElementById("topicText").textContent =
          currentQuestion.topicText;

        // Set topic questions
        const questionsContainer = document.getElementById("topicQuestions");
        questionsContainer.innerHTML = "";
        currentQuestion.topicQuestions.forEach((question) => {
          const li = document.createElement("li");
          li.textContent = question;
          questionsContainer.appendChild(li);
        });

        // Set initial state - preparation mode
        document.getElementById("questionTitle").textContent =
          "Prepare to speak about the topic below";
        document.getElementById("questionSubtitle").textContent =
          "You will have 90 seconds to speak";
        document.getElementById("timerLabel").textContent = "to prepare";

        // Show record button, hide others
        document.getElementById("recordButton").style.display = "block";
        document.getElementById("recordingStatus").style.display = "none";
        document.getElementById("audioVisualizer").style.display = "none";
        document.getElementById("continueBtn").style.display = "none";

        // Hide review section and results
        document.getElementById("reviewSection").style.display = "none";
        document.getElementById("resultsScreen").style.display = "none";
        document.getElementById("questionCard").style.display = "flex";

        // Start prepare timer
        startPrepareTimer();
      }

      function resetUI() {
        // Clear timers
        clearInterval(timerInterval);
        clearTimeout(prepareTimeout);
        clearTimeout(recordingTimeout);

        // Stop any playing audio
        stopAllAudio();

        // Reset record button
        const recordButton = document.getElementById("recordButton");
        recordButton.classList.remove("recording");
        recordButton.style.display = "block";

        // Hide status elements initially
        document.getElementById("recordingStatus").style.display = "none";
        document.getElementById("audioVisualizer").style.display = "none";
        document.getElementById("continueBtn").style.display = "none";

        // Reset timer
        document.getElementById("timer").classList.remove("warning");

        // Stop any recording
        if (mediaRecorder && mediaRecorder.state === "recording") {
          mediaRecorder.stop();
        }

        // Reset recorded data
        recordedChunks = [];
        recordedBlob = null;
      }

      function startPrepareTimer() {
        questionStartTime = Date.now();
        let seconds = 0;
        const maxSeconds = PREPARE_TIME / 1000; // 15 seconds

        timerInterval = setInterval(() => {
          seconds++;
          const minutes = Math.floor(seconds / 60);
          const remainingSeconds = seconds % 60;

          const timerElement = document.getElementById("timer");
          const timerText = document.getElementById("timerText");

          timerText.textContent = `${minutes}:${remainingSeconds
            .toString()
            .padStart(2, "0")}`;

          // Warning color after 10 seconds
          if (seconds >= 10) {
            timerElement.classList.add("warning");
          }

          if (seconds >= maxSeconds) {
            clearInterval(timerInterval);
            // Auto start recording after 15 seconds
            startRecording();
          }
        }, 1000);

        // Set timeout to auto-start recording after 15 seconds
        prepareTimeout = setTimeout(() => {
          startRecording();
        }, PREPARE_TIME);
      }

      async function handleRecord() {
        if (currentStep === "prepare") {
          // User clicked record button during preparation
          clearTimeout(prepareTimeout);
          clearInterval(timerInterval);
          startRecording();
        }
      }

      async function startRecording() {
        currentStep = "speaking";

        // Track preparation time and start speaking time
        actualPreparationTime = Date.now() - questionPrepStartTime;
        questionSpeakStartTime = Date.now();

        // Update UI for recording mode
        document.getElementById("questionTitle").textContent =
          "Speak about the topic below";
        document.getElementById("questionSubtitle").textContent =
          "You have 90 seconds to speak";
        document.getElementById("recordButton").style.display = "none";
        document.getElementById("recordingStatus").style.display = "flex";
        document.getElementById("audioVisualizer").style.display = "flex";
        document.getElementById("continueBtn").style.display = "block";

        // Start recording timer
        startRecordingTimer();

        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
          mediaRecorder = new MediaRecorder(stream);
          recordedChunks = [];

          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              recordedChunks.push(event.data);
            }
          };

          mediaRecorder.onstop = () => {
            recordedBlob = new Blob(recordedChunks, { type: "audio/wav" });
            stream.getTracks().forEach((track) => track.stop());

            // Calculate actual speaking time and save answer data
            actualSpeakingTime = Date.now() - questionSpeakStartTime;
            saveAnswerData();
          };

          mediaRecorder.start();
          console.log("Recording started");
        } catch (error) {
          console.error("Error starting recording:", error);
          alert("Could not access microphone. Please check permissions.");
        }
      }

      function startRecordingTimer() {
        let seconds = 0;
        const maxSeconds = quizConfig.speakingTime || 90; // Convert to seconds

        document.getElementById("timerLabel").textContent = "to speak";
        document.getElementById("timer").classList.remove("warning");

        timerInterval = setInterval(() => {
          seconds++;
          const minutes = Math.floor(seconds / 60);
          const remainingSeconds = seconds % 60;

          const timerElement = document.getElementById("timer");
          const timerText = document.getElementById("timerText");

          timerText.textContent = `${minutes}:${remainingSeconds
            .toString()
            .padStart(2, "0")}`;

          if (seconds >= maxSeconds) {
            clearInterval(timerInterval);
            stopRecording();
          }
        }, 1000);

        // Set timeout to auto-stop recording
        recordingTimeout = setTimeout(() => {
          stopRecording();
        }, (quizConfig.speakingTime || 90) * 1000);
      }

      function stopRecording() {
        if (mediaRecorder && mediaRecorder.state === "recording") {
          mediaRecorder.stop();
        }

        clearInterval(timerInterval);
        clearTimeout(recordingTimeout);

        // Calculate actual speaking time if not already calculated
        if (actualSpeakingTime === 0) {
          actualSpeakingTime = Date.now() - questionSpeakStartTime;
          saveAnswerData();
        }

        // Hide recording status and audio visualizer
        document.getElementById("recordingStatus").style.display = "none";
        document.getElementById("audioVisualizer").style.display = "none";

        console.log("Recording stopped");
      }
      function saveAnswerData() {
        const totalTime = actualPreparationTime + actualSpeakingTime;
        const maxSpeakingTime = (quizConfig.speakingTime || 90) * 1000; // Convert to milliseconds
        const timeUtilized = Math.min(
          (actualSpeakingTime / maxSpeakingTime) * 100,
          100
        );

        const answerData = {
          questionId: currentQuestion.id,
          topicText: currentQuestion.topicText,
          topicQuestions: currentQuestion.topicQuestions,
          sampleAnswer: currentQuestion.sampleAnswer,
          preparationTime: actualPreparationTime,
          speakingTime: actualSpeakingTime,
          totalTime: totalTime,
          timeUtilized: Math.round(timeUtilized),
          timestamp: new Date().toISOString(),
        };

        answers.push(answerData);
        console.log("Answer data saved:", answerData);
      }
      function nextStep() {
        if (currentStep === "speaking") {
          stopRecording();
          showReview();
        }
      }

      function showReview() {
        currentStep = "review";

        // Keep question card visible but hide the continue button
        document.getElementById("continueBtn").style.display = "none";

        // Hide recording status and audio visualizer since recording is done
        document.getElementById("recordingStatus").style.display = "none";
        document.getElementById("audioVisualizer").style.display = "none";

        // Show review section
        document.getElementById("reviewSection").style.display = "block";
      }

      function stopAllAudio() {
        // Stop text-to-speech
        if (speechSynthesis) {
          speechSynthesis.cancel();
        }

        // Stop sample audio
        if (sampleAudio) {
          sampleAudio.pause();
          sampleAudio.currentTime = 0;
        }

        // Stop recording audio
        if (recordingAudio) {
          recordingAudio.pause();
          recordingAudio.currentTime = 0;
        }

        // Reset button states
        resetAudioButtons();

        isPlayingSample = false;
        isPlayingRecording = false;
      }

      function resetAudioButtons() {
        // Reset sample button
        const sampleBtn = document.getElementById("sampleBtn");
        const samplePlayIcon = document.getElementById("samplePlayIcon");
        const sampleStopIcon = document.getElementById("sampleStopIcon");
        const sampleBtnText = document.getElementById("sampleBtnText");

        if (sampleBtn) {
          sampleBtn.classList.remove("playing");
          samplePlayIcon.style.display = "block";
          sampleStopIcon.style.display = "none";
          sampleBtnText.textContent = "SAMPLE";
        }

        // Reset recording button
        const recordingBtn = document.getElementById("recordingBtn");
        const recordingPlayIcon = document.getElementById("recordingPlayIcon");
        const recordingStopIcon = document.getElementById("recordingStopIcon");
        const recordingBtnText = document.getElementById("recordingBtnText");

        if (recordingBtn) {
          recordingBtn.classList.remove("playing");
          recordingPlayIcon.style.display = "block";
          recordingStopIcon.style.display = "none";
          recordingBtnText.textContent = "YOUR RECORDING";
        }
      }

      function toggleSample() {
        if (isPlayingSample) {
          stopAllAudio();
        } else {
          stopAllAudio();
          playSample();
        }
      }

      function playSample() {
        if (!speechSynthesis) {
          alert("Text-to-speech is not supported in your browser");
          return;
        }

        try {
          isPlayingSample = true;

          // Update button appearance
          const sampleBtn = document.getElementById("sampleBtn");
          const samplePlayIcon = document.getElementById("samplePlayIcon");
          const sampleStopIcon = document.getElementById("sampleStopIcon");
          const sampleBtnText = document.getElementById("sampleBtnText");

          sampleBtn.classList.add("playing");
          samplePlayIcon.style.display = "none";
          sampleStopIcon.style.display = "block";
          sampleBtnText.textContent = "STOP";

          // Create utterance
          currentUtterance = new SpeechSynthesisUtterance(
            currentQuestion.sampleAnswer
          );

          // Configure speech
          currentUtterance.rate = 0.9;
          currentUtterance.pitch = 1.0;
          currentUtterance.volume = 0.8;

          // Try to use an English voice
          const voices = speechSynthesis.getVoices();
          const englishVoice =
            voices.find(
              (voice) =>
                voice.lang.startsWith("en") && !voice.name.includes("Google")
            ) || voices.find((voice) => voice.lang.startsWith("en"));

          if (englishVoice) {
            currentUtterance.voice = englishVoice;
          }

          // Handle speech end
          currentUtterance.onend = () => {
            isPlayingSample = false;
            resetAudioButtons();
          };

          currentUtterance.onerror = () => {
            isPlayingSample = false;
            resetAudioButtons();
          };

          // Speak the text
          speechSynthesis.speak(currentUtterance);
        } catch (error) {
          console.error("Error with text-to-speech:", error);
          alert("Error playing sample audio");
          isPlayingSample = false;
          resetAudioButtons();
        }
      }

      function toggleRecording() {
        if (isPlayingRecording) {
          stopAllAudio();
        } else {
          stopAllAudio();
          playRecording();
        }
      }

      function playRecording() {
        if (!recordedBlob) {
          alert("No recording available");
          return;
        }

        try {
          isPlayingRecording = true;

          // Update button appearance
          const recordingBtn = document.getElementById("recordingBtn");
          const recordingPlayIcon =
            document.getElementById("recordingPlayIcon");
          const recordingStopIcon =
            document.getElementById("recordingStopIcon");
          const recordingBtnText = document.getElementById("recordingBtnText");

          recordingBtn.classList.add("playing");
          recordingPlayIcon.style.display = "none";
          recordingStopIcon.style.display = "block";
          recordingBtnText.textContent = "STOP";

          const audioUrl = URL.createObjectURL(recordedBlob);
          recordingAudio = document.getElementById("recordingAudio");
          recordingAudio.src = audioUrl;

          recordingAudio.onended = () => {
            isPlayingRecording = false;
            resetAudioButtons();
            URL.revokeObjectURL(audioUrl);
          };

          recordingAudio.onerror = () => {
            isPlayingRecording = false;
            resetAudioButtons();
            URL.revokeObjectURL(audioUrl);
          };

          recordingAudio.play();
        } catch (error) {
          console.error("Error playing recording:", error);
          alert("Error playing your recording");
          isPlayingRecording = false;
          resetAudioButtons();
        }
      }

      function showResults() {
        stagesCompletedThisSession++;
        saveDetailedQuizResult("Read Then Speak");

        stopAllAudio();
        document.getElementById("questionCard").style.display = "none";
        document.getElementById("reviewSection").style.display = "none";
        document.getElementById("resultsScreen").style.display = "block";
      }

      function continueToNextStage() {
        if (stagesCompletedThisSession >= STAGES_TOTAL && typeof getNextQuizUrl === "function") {
          const nextUrl = getNextQuizUrl("Read, Then Speak");
          if (nextUrl) {
            window.location.href = nextUrl;
            return;
          }
        }
        const completedId = currentQuestion?.id;
        resetUI();
        document.getElementById("resultsScreen").style.display = "none";
        document.getElementById("questionCard").style.display = "flex";
        initializeQuiz(completedId);
      }

      // Go to Practice Page
      function goToPractice() {
        stopAllAudio();
        const progressKey = "skillProgress";
        const allProgress = JSON.parse(localStorage.getItem(progressKey)) || {};
        const currentProgress = allProgress["Read, Then Speak"] || {
          completed: 0,
          total: 3,
        };
        if (currentProgress.completed < currentProgress.total) {
          incrementSkillProgress("Read, Then Speak", stagesCompletedThisSession);
        }
        window.location.href = "index.html";
      }
      function saveDetailedQuizResult(skillName) {
        const sessionData = calculateSessionMetrics();

        // Create session result object
        const sessionResult = {
          skillName: skillName,
          sessionId: Date.now(),
          date: new Date().toISOString(),

          // Basic performance data
          totalQuestions: 1, // Read Then Speak typically has 1 question per session
          correctAnswers: 1, // All speaking responses are considered "completed"
          accuracy: 100, // Speaking tasks are evaluated differently

          // Time analysis
          totalTimeSpent: sessionData.totalTime,
          averageTimePerQuestion: sessionData.avgTime,

          // Performance analysis for speaking
          consistency: sessionData.consistency,
          difficultyHandling: sessionData.difficultyScore,
          speakingFluency: sessionData.speakingFluency,
          contentQuality: sessionData.contentQuality,
          timeUtilization: sessionData.timeUtilization,
          preparationEfficiency: sessionData.preparationEfficiency,

          // Final session score
          sessionScore: calculateSessionScore(sessionData),

          // Individual question details
          questionDetails: answers.map((answer, index) => ({
            questionId: answer.questionId,
            questionType: "read_then_speak",
            difficulty: determineTopicDifficulty(answer),
            speakingTime: answer.speakingTime,
            preparationTime: answer.preparationTime,
            totalTime: answer.totalTime,
            timeUtilized: answer.timeUtilized,
            topicType: categorizeTopicType(answer),
            sampleAnswer: answer.sampleAnswer,
            expectedElements: extractExpectedElements(answer.sampleAnswer),
          })),
        };
        function calculateSessionMetrics() {
          const totalTime = answers.reduce(
            (sum, answer) => sum + answer.totalTime,
            0
          );
          const avgTime = totalTime / answers.length;

          // Calculate consistency - how stable speaking times are
          const speakingTimes = answers.map((answer) => answer.speakingTime);
          const avgSpeakingTime =
            speakingTimes.reduce((sum, time) => sum + time, 0) /
            speakingTimes.length;

          const timeDeviations = speakingTimes.map((time) =>
            Math.abs(time - avgSpeakingTime)
          );
          const avgDeviation =
            timeDeviations.reduce((sum, dev) => sum + dev, 0) /
            timeDeviations.length;
          const consistency = Math.max(
            0,
            100 - (avgDeviation / avgSpeakingTime) * 100
          );

          // Calculate difficulty handling score
          const difficultyScore = calculateDifficultyHandling();

          // Calculate speaking fluency (based on time utilization)
          const speakingFluency = calculateSpeakingFluency();

          // Calculate content quality (estimated based on time usage patterns)
          const contentQuality = calculateContentQuality();

          // Calculate time utilization efficiency
          const timeUtilization = calculateTimeUtilization();

          // Calculate preparation efficiency
          const preparationEfficiency = calculatePreparationEfficiency();

          return {
            totalTime: Math.round(totalTime / 1000), // Convert to seconds
            avgTime: Math.round(avgTime / 1000), // Convert to seconds
            consistency: Math.round(consistency),
            difficultyScore: difficultyScore,
            speakingFluency: speakingFluency,
            contentQuality: contentQuality,
            timeUtilization: timeUtilization,
            preparationEfficiency: preparationEfficiency,
          };
        }
        function determineTopicDifficulty(answer) {
          let difficulty = 1; // Base difficulty (Easy)

          const topicText = answer.topicText.toLowerCase();
          const sampleAnswer = answer.sampleAnswer.toLowerCase();

          // Analyze sample answer complexity
          const sampleWords = answer.sampleAnswer.split(" ").length;
          const sampleSentences = answer.sampleAnswer
            .split(/[.!?]+/)
            .filter((s) => s.trim().length > 0).length;

          // Length-based complexity
          if (sampleWords > 100 || sampleSentences > 7) {
            difficulty += 1; // Complex topics
          } else if (sampleWords > 80 || sampleSentences > 5) {
            difficulty += 0.5; // Medium complexity
          }

          // Topic complexity indicators
          const complexTopics = [
            "technology",
            "culture",
            "society",
            "environment",
            "economy",
            "politics",
            "philosophy",
            "abstract",
            "analyze",
            "evaluate",
            "compare",
            "contrast",
            "argue",
            "defend",
            "justify",
          ];
          const hasComplexElements = complexTopics.some(
            (element) =>
              topicText.includes(element) || sampleAnswer.includes(element)
          );
          if (hasComplexElements) {
            difficulty += 0.5;
          }

          // Multiple question indicators (more complex to address multiple points)
          if (answer.topicQuestions.length > 2) {
            difficulty += 0.3;
          }

          // Abstract vs concrete topics
          const abstractTerms = [
            "importance",
            "role",
            "impact",
            "effect",
            "influence",
            "benefit",
            "challenge",
            "advantage",
            "disadvantage",
          ];
          if (abstractTerms.some((term) => topicText.includes(term))) {
            difficulty += 0.4;
          }

          // Clamp difficulty between 1-3
          difficulty = Math.max(1, Math.min(3, difficulty));

          if (difficulty <= 1.5) return "easy";
          if (difficulty <= 2.5) return "medium";
          return "hard";
        }
        function categorizeTopicType(answer) {
          const topicText = answer.topicText.toLowerCase();
          const sampleAnswer = answer.sampleAnswer.toLowerCase();

          if (
            topicText.includes("hobby") ||
            topicText.includes("interest") ||
            topicText.includes("enjoy")
          ) {
            return "personal_interests";
          } else if (
            topicText.includes("family") ||
            topicText.includes("friend") ||
            topicText.includes("relationship")
          ) {
            return "relationships";
          } else if (
            topicText.includes("place") ||
            topicText.includes("travel") ||
            topicText.includes("visit")
          ) {
            return "places_travel";
          } else if (
            topicText.includes("job") ||
            topicText.includes("work") ||
            topicText.includes("career")
          ) {
            return "work_career";
          } else if (
            topicText.includes("technology") ||
            topicText.includes("modern") ||
            topicText.includes("internet")
          ) {
            return "technology";
          } else if (
            topicText.includes("health") ||
            topicText.includes("exercise") ||
            topicText.includes("food")
          ) {
            return "health_lifestyle";
          } else if (
            topicText.includes("culture") ||
            topicText.includes("festival") ||
            topicText.includes("celebration")
          ) {
            return "culture";
          }

          return "general";
        }
        function extractExpectedElements(sampleAnswer) {
          const elements = [];
          const words = sampleAnswer.toLowerCase().split(" ");

          // Key speaking elements for Read Then Speak
          const structuralElements = [
            "first",
            "second",
            "also",
            "because",
            "however",
            "therefore",
            "for example",
            "in conclusion",
            "moreover",
            "furthermore",
          ];
          const descriptiveElements = [
            "important",
            "special",
            "interesting",
            "beautiful",
            "useful",
            "helpful",
            "enjoyable",
            "necessary",
            "effective",
            "beneficial",
          ];
          const personalElements = [
            "i think",
            "i believe",
            "in my opinion",
            "i feel",
            "my experience",
            "personally",
            "i would",
            "i like",
            "i enjoy",
            "i prefer",
          ];

          structuralElements.forEach((element) => {
            if (sampleAnswer.toLowerCase().includes(element))
              elements.push(element);
          });

          descriptiveElements.forEach((element) => {
            if (words.includes(element)) elements.push(element);
          });

          personalElements.forEach((element) => {
            if (sampleAnswer.toLowerCase().includes(element))
              elements.push(element);
          });

          return elements;
        }
        // Calculate how well user handles different difficulty levels
        function calculateDifficultyHandling() {
          const difficultyStats = {
            easy: { responses: 0, totalTime: 0, avgUtilization: 0 },
            medium: { responses: 0, totalTime: 0, avgUtilization: 0 },
            hard: { responses: 0, totalTime: 0, avgUtilization: 0 },
          };

          // Analyze performance by difficulty
          answers.forEach((answer) => {
            const difficulty = determineTopicDifficulty(answer);
            difficultyStats[difficulty].responses++;
            difficultyStats[difficulty].totalTime += answer.speakingTime;
            difficultyStats[difficulty].avgUtilization += answer.timeUtilized;
          });

          // Calculate weighted score based on difficulty handling
          let weightedScore = 0;
          let totalWeight = 0;

          Object.entries(difficultyStats).forEach(([difficulty, stats]) => {
            if (stats.responses > 0) {
              const avgTime = stats.totalTime / stats.responses;
              const avgUtilization = stats.avgUtilization / stats.responses;

              // Score based on appropriate time usage for difficulty level
              let difficultyScore = 50; // Base score

              // Time utilization bonus (using most of available time is good)
              if (avgUtilization > 70) {
                difficultyScore += 30;
              } else if (avgUtilization > 50) {
                difficultyScore += 20;
              } else if (avgUtilization > 30) {
                difficultyScore += 10;
              }

              // Consistency bonus for appropriate speaking time
              const expectedTime =
                difficulty === "easy"
                  ? 60000
                  : difficulty === "medium"
                  ? 75000
                  : 85000; // milliseconds
              if (Math.abs(avgTime - expectedTime) < expectedTime * 0.2) {
                difficultyScore += 20;
              }

              const weight =
                difficulty === "easy" ? 1 : difficulty === "medium" ? 1.5 : 2;
              weightedScore += difficultyScore * weight;
              totalWeight += weight;
            }
          });

          return totalWeight > 0 ? Math.round(weightedScore / totalWeight) : 0;
        }

        // Calculate speaking fluency based on time patterns
        function calculateSpeakingFluency() {
          let fluencyScore = 0;
          let validResponses = 0;

          answers.forEach((answer) => {
            validResponses++;
            let responseScore = 0;

            // Time utilization score (using 70-95% of available time is optimal)
            const utilization = answer.timeUtilized;
            if (utilization >= 70 && utilization <= 95) {
              responseScore += 40;
            } else if (utilization >= 50 && utilization < 70) {
              responseScore += 25;
            } else if (utilization > 95) {
              responseScore += 35; // Good but might be rushed at the end
            }

            // Consistency in speaking time (not too much variation)
            const speakingTimeSeconds = answer.speakingTime / 1000;
            if (speakingTimeSeconds >= 60 && speakingTimeSeconds <= 85) {
              responseScore += 30;
            } else if (speakingTimeSeconds >= 45 && speakingTimeSeconds <= 60) {
              responseScore += 20;
            }

            // Preparation vs speaking time balance
            const prepRatio =
              answer.preparationTime /
              (answer.preparationTime + answer.speakingTime);
            if (prepRatio >= 0.1 && prepRatio <= 0.2) {
              // 10-20% preparation time is good
              responseScore += 20;
            } else if (prepRatio >= 0.05 && prepRatio <= 0.25) {
              responseScore += 10;
            }

            // Timing efficiency (not running over time limits)
            if (answer.speakingTime <= 92000) {
              // Within 92 seconds (allowing small buffer)
              responseScore += 10;
            }

            fluencyScore += Math.min(responseScore, 100);
          });

          return validResponses > 0
            ? Math.round(fluencyScore / validResponses)
            : 0;
        }

        // Calculate estimated content quality based on speaking patterns
        function calculateContentQuality() {
          let qualityScore = 0;
          let validResponses = 0;

          answers.forEach((answer) => {
            validResponses++;
            let responseScore = 50; // Base score

            // Length appropriateness (longer speaking generally indicates more content)
            const speakingTimeSeconds = answer.speakingTime / 1000;
            if (speakingTimeSeconds >= 70 && speakingTimeSeconds <= 90) {
              responseScore += 25; // Optimal length
            } else if (speakingTimeSeconds >= 50 && speakingTimeSeconds < 70) {
              responseScore += 15; // Good length
            } else if (speakingTimeSeconds >= 30 && speakingTimeSeconds < 50) {
              responseScore += 5; // Short but acceptable
            }

            // Preparation time usage (good preparation usually leads to better content)
            const prepTimeSeconds = answer.preparationTime / 1000;
            if (prepTimeSeconds >= 8 && prepTimeSeconds <= 15) {
              responseScore += 15; // Good preparation time
            } else if (prepTimeSeconds >= 5 && prepTimeSeconds < 8) {
              responseScore += 10; // Some preparation
            }

            // Difficulty bonus (speaking well about complex topics deserves more points)
            const difficulty = determineTopicDifficulty(answer);
            if (difficulty === "hard" && speakingTimeSeconds >= 60) {
              responseScore += 10;
            } else if (difficulty === "medium" && speakingTimeSeconds >= 45) {
              responseScore += 5;
            }

            qualityScore += Math.min(responseScore, 100);
          });

          return validResponses > 0
            ? Math.round(qualityScore / validResponses)
            : 0;
        }

        // Calculate time utilization efficiency
        function calculateTimeUtilization() {
          const totalUtilization = answers.reduce(
            (sum, answer) => sum + answer.timeUtilized,
            0
          );
          return answers.length > 0
            ? Math.round(totalUtilization / answers.length)
            : 0;
        }

        // Calculate preparation efficiency
        function calculatePreparationEfficiency() {
          let efficiencyScore = 0;
          let validResponses = 0;

          answers.forEach((answer) => {
            validResponses++;
            const prepTime = answer.preparationTime / 1000; // Convert to seconds

            // Optimal preparation time is 8-12 seconds for Read Then Speak
            if (prepTime >= 8 && prepTime <= 12) {
              efficiencyScore += 100;
            } else if (prepTime >= 5 && prepTime <= 15) {
              efficiencyScore += 80;
            } else if (prepTime >= 3 && prepTime <= 18) {
              efficiencyScore += 60;
            } else {
              efficiencyScore += 40; // Too little or too much preparation
            }
          });

          return validResponses > 0
            ? Math.round(efficiencyScore / validResponses)
            : 0;
        }

        // Calculate final session score
        function calculateSessionScore(sessionData) {
          // Scoring weights for Read Then Speak tasks
          const weights = {
            speakingFluency: 0.3, // 30% - Most important for speaking
            contentQuality: 0.25, // 25% - Quality of content
            timeUtilization: 0.2, // 20% - Using available time well
            preparationEfficiency: 0.1, // 10% - Good preparation
            consistency: 0.1, // 10% - Consistent performance
            difficulty: 0.05, // 5% - Handling complex topics
          };

          // Calculate final weighted score
          const finalScore =
            sessionData.speakingFluency * weights.speakingFluency +
            sessionData.contentQuality * weights.contentQuality +
            sessionData.timeUtilization * weights.timeUtilization +
            sessionData.preparationEfficiency * weights.preparationEfficiency +
            sessionData.consistency * weights.consistency +
            sessionData.difficultyScore * weights.difficulty;

          return Math.round(Math.max(0, Math.min(100, finalScore)));
        }
        // Save session to localStorage history
        function saveSessionToHistory(skillName, sessionResult) {
          const historyKey = `${skillName
            .replace(/\s+/g, "_")
            .toLowerCase()}_sessions`;

          try {
            // Get existing sessions
            const existingSessions = localStorage.getItem(historyKey);
            const sessions = existingSessions
              ? JSON.parse(existingSessions)
              : [];

            // Add new session
            sessions.push(sessionResult);

            // Keep only last 20 sessions to prevent storage overflow
            if (sessions.length > 20) {
              sessions.splice(0, sessions.length - 20);
            }

            // Save back to localStorage
            localStorage.setItem(historyKey, JSON.stringify(sessions));

            console.log(
              `Saved session to ${historyKey}. Total sessions: ${sessions.length}`
            );

            // Update overall skill assessment
            updateSkillOverallAssessment(skillName, sessions);
          } catch (error) {
            console.error("Error saving session to history:", error);
          }
        }
        // Update overall skill assessment based on all sessions
        function updateSkillOverallAssessment(skillName, allSessions) {
          if (!allSessions || allSessions.length === 0) return;

          // Calculate overall metrics for Read Then Speak
          const avgSpeakingFluency =
            allSessions.reduce(
              (sum, session) => sum + session.speakingFluency,
              0
            ) / allSessions.length;

          const avgContentQuality =
            allSessions.reduce(
              (sum, session) => sum + session.contentQuality,
              0
            ) / allSessions.length;

          const avgTimeUtilization =
            allSessions.reduce(
              (sum, session) => sum + session.timeUtilization,
              0
            ) / allSessions.length;

          // Calculate improvement (compare first vs last session)
          const firstSession = allSessions[0];
          const lastSession = allSessions[allSessions.length - 1];
          const improvement =
            lastSession.speakingFluency - firstSession.speakingFluency;

          // Calculate average session score
          const avgSessionScore =
            allSessions.reduce(
              (sum, session) => sum + session.sessionScore,
              0
            ) / allSessions.length;

          // Calculate consistency across sessions
          const sessionScores = allSessions.map((s) => s.sessionScore);
          const scoreStdDev = calculateStandardDeviation(sessionScores);
          const crossSessionConsistency = Math.max(0, 100 - scoreStdDev);

          // Final skill score calculation
          const skillWeights = {
            speakingFluency: 0.35,
            contentQuality: 0.25,
            timeUtilization: 0.2,
            avgScore: 0.15,
            improvement: 0.05,
          };

          const normalizedImprovement = Math.max(
            0,
            Math.min(100, improvement + 50)
          ); // Normalize to 0-100

          const finalSkillScore =
            avgSpeakingFluency * skillWeights.speakingFluency +
            avgContentQuality * skillWeights.contentQuality +
            avgTimeUtilization * skillWeights.timeUtilization +
            avgSessionScore * skillWeights.avgScore +
            normalizedImprovement * skillWeights.improvement;

          // Create overall assessment
          const skillAssessment = {
            skillName: skillName,
            lastUpdated: new Date().toISOString(),
            sessionsCompleted: allSessions.length,

            // Performance metrics
            averageSpeakingFluency: Math.round(avgSpeakingFluency),
            averageContentQuality: Math.round(avgContentQuality),
            averageTimeUtilization: Math.round(avgTimeUtilization),
            averageSessionScore: Math.round(avgSessionScore),
            improvement: Math.round(improvement),
            consistency: Math.round(crossSessionConsistency),

            // Read Then Speak specific metrics
            averagePreparationEfficiency: Math.round(
              allSessions.reduce((sum, s) => sum + s.preparationEfficiency, 0) /
                allSessions.length
            ),
            averageSpeakingTime: Math.round(
              allSessions.reduce(
                (sum, s) => sum + s.averageTimePerQuestion,
                0
              ) / allSessions.length
            ),

            // Final score
            finalScore: Math.round(finalSkillScore),
            level: determineSkillLevel(finalSkillScore),

            // Additional insights
            strongPoints: identifyStrongPoints(allSessions),
            weakPoints: identifyWeakPoints(allSessions),
            recommendations: generateRecommendations(
              allSessions,
              finalSkillScore
            ),
          };

          // Save overall assessment
          const assessmentKey = `${skillName
            .replace(/\s+/g, "_")
            .toLowerCase()}_assessment`;
          localStorage.setItem(assessmentKey, JSON.stringify(skillAssessment));

          console.log(
            `Updated overall assessment for ${skillName}:`,
            skillAssessment
          );
        }

        // Helper function to calculate standard deviation
        function calculateStandardDeviation(values) {
          const mean =
            values.reduce((sum, val) => sum + val, 0) / values.length;
          const squaredDiffs = values.map((val) => Math.pow(val - mean, 2));
          const avgSquaredDiff =
            squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
          return Math.sqrt(avgSquaredDiff);
        }

        // Determine skill level based on final score
        function determineSkillLevel(score) {
          if (score >= 90) return "Advanced";
          if (score >= 75) return "Upper-Intermediate";
          if (score >= 60) return "Intermediate";
          if (score >= 45) return "Lower-Intermediate";
          if (score >= 30) return "Elementary";
          return "Beginner";
        }

        // Identify strong points from session data
        function identifyStrongPoints(sessions) {
          const strongPoints = [];

          // Check speaking fluency
          const avgSpeakingFluency =
            sessions.reduce((sum, s) => sum + s.speakingFluency, 0) /
            sessions.length;
          if (avgSpeakingFluency >= 80) {
            strongPoints.push("Excellent speaking fluency and flow");
          }

          // Check content quality
          const avgContentQuality =
            sessions.reduce((sum, s) => sum + s.contentQuality, 0) /
            sessions.length;
          if (avgContentQuality >= 75) {
            strongPoints.push("High quality responses to topic questions");
          }

          // Check time utilization
          const avgTimeUtilization =
            sessions.reduce((sum, s) => sum + s.timeUtilization, 0) /
            sessions.length;
          if (avgTimeUtilization >= 80) {
            strongPoints.push("Excellent time management during speaking");
          }

          // Identify weak points from session data
          function identifyWeakPoints(sessions) {
            const weakPoints = [];

            // Check speaking fluency
            const avgSpeakingFluency =
              sessions.reduce((sum, s) => sum + s.speakingFluency, 0) /
              sessions.length;
            if (avgSpeakingFluency < 60) {
              weakPoints.push("Speaking fluency needs improvement");
            }

            // Check content quality
            const avgContentQuality =
              sessions.reduce((sum, s) => sum + s.contentQuality, 0) /
              sessions.length;
            if (avgContentQuality < 65) {
              weakPoints.push(
                "Focus on providing more detailed topic responses"
              );
            }

            // Check time utilization
            const avgTimeUtilization =
              sessions.reduce((sum, s) => sum + s.timeUtilization, 0) /
              sessions.length;
            if (avgTimeUtilization < 60) {
              weakPoints.push("Try to use more of the available speaking time");
            } else if (avgTimeUtilization > 98) {
              weakPoints.push("Practice pacing to avoid rushing at the end");
            }

            // Check preparation efficiency
            const avgPrepEfficiency =
              sessions.reduce((sum, s) => sum + s.preparationEfficiency, 0) /
              sessions.length;
            if (avgPrepEfficiency >= 85) {
              strongPoints.push("Efficient preparation before speaking");
            }
            // Check consistency
            const sessionScores = sessions.map((s) => s.sessionScore);
            const scoreStdDev = calculateStandardDeviation(sessionScores);
            if (scoreStdDev <= 10) {
              strongPoints.push("Consistent performance across sessions");
            }
          }
        }

        // Generate personalized recommendations
        function generateRecommendations(sessions, finalScore) {
          const recommendations = [];

          if (finalScore < 50) {
            recommendations.push(
              "Practice speaking about familiar topics first"
            );
            recommendations.push(
              "Use the full preparation time to organize thoughts"
            );
            recommendations.push(
              "Focus on answering all topic questions clearly"
            );
          } else if (finalScore < 70) {
            recommendations.push(
              "Work on speaking for the full time available"
            );
            recommendations.push(
              "Practice organizing responses with clear structure"
            );
            recommendations.push(
              "Try to provide examples and details in answers"
            );
          } else if (finalScore < 85) {
            recommendations.push("Challenge yourself with more complex topics");
            recommendations.push(
              "Practice advanced speaking techniques and transitions"
            );
            recommendations.push("Work on fluency and natural speech patterns");
          } else {
            recommendations.push(
              "Excellent work! Try discussing abstract concepts"
            );
            recommendations.push(
              "Practice with professional or academic topics"
            );
            recommendations.push("Help others improve their speaking skills");
          }

          // Specific recommendations based on metrics
          const avgTimeUtilization =
            sessions.reduce((sum, s) => sum + s.timeUtilization, 0) /
            sessions.length;
          if (avgTimeUtilization < 70) {
            recommendations.push(
              "Practice speaking for the full 90 seconds available"
            );
          }

          const avgPrepEfficiency =
            sessions.reduce((sum, s) => sum + s.preparationEfficiency, 0) /
            sessions.length;
          if (avgPrepEfficiency < 75) {
            recommendations.push(
              "Use preparation time more effectively to plan your response structure"
            );
          }

          return recommendations;
        }
        // Save result to localStorage
        saveSessionToHistory(skillName, sessionResult);
        console.log(`Session saved for ${skillName}:`, sessionResult);
      }
      // Function to increment progress by 1 or more
      function incrementSkillProgress(skillName, count = 1) {
        try {
          // Get current progress data from localStorage
          const progressKey = "skillProgress";
          const allProgress =
            JSON.parse(localStorage.getItem(progressKey)) || {};

          // Initialize progress data if it doesn't exist for this skill
          if (!allProgress[skillName]) {
            allProgress[skillName] = {
              completed: 0,
              total: 3,
              lastUpdated: new Date().toISOString(),
            };
          }

          // Increment progress while ensuring it doesn't exceed the maximum
          allProgress[skillName].completed = Math.min(
            allProgress[skillName].completed + count,
            allProgress[skillName].total
          );
          allProgress[skillName].lastUpdated = new Date().toISOString();

          // Save updated progress back to localStorage
          localStorage.setItem(progressKey, JSON.stringify(allProgress));

          console.log(
            `Progress updated for ${skillName}: ${allProgress[skillName].completed}/${allProgress[skillName].total}`
          );

          // Dispatch event to notify main page of progress update
          const progressEvent = new CustomEvent("progressUpdated", {
            detail: {
              skill: skillName,
              progress: allProgress[skillName],
            },
          });
          window.dispatchEvent(progressEvent);

          return true;
        } catch (error) {
          console.error("Error updating progress:", error);
          return false;
        }
      }
      function getSkillProgress(skillName) {
        try {
          const progressKey = "skillProgress";
          const allProgress =
            JSON.parse(localStorage.getItem(progressKey)) || {};
          return allProgress[skillName] || { completed: 0, total: 3 };
        } catch (error) {
          console.error("Error getting progress:", error);
          return { completed: 0, total: 3 };
        }
      }

      function resetSkillProgress(skillName) {
        try {
          const progressKey = "skillProgress";
          const allProgress =
            JSON.parse(localStorage.getItem(progressKey)) || {};
          allProgress[skillName] = {
            completed: 0,
            total: 3,
            lastUpdated: new Date().toISOString(),
          };
          localStorage.setItem(progressKey, JSON.stringify(allProgress));
          return true;
        } catch (error) {
          console.error("Error resetting progress:", error);
          return false;
        }
      }
      // Function to get current skill progress from localStorage
      function getCurrentSkillProgress(skillName) {
        try {
          // Check if there's existing progress in the main app
          const mainProgressData = localStorage.getItem("skillProgress");
          if (mainProgressData) {
            const allProgress = JSON.parse(mainProgressData);
            if (allProgress[skillName]) {
              return allProgress[skillName].completed || 0;
            }
          }
          return 0;
        } catch (error) {
          console.error("Error reading current progress:", error);
          return 0;
        }
      }

      function goBack() {
        if (confirm("Are you sure you want to exit the quiz?")) {
          if (stagesCompletedThisSession > 0) {
            incrementSkillProgress("Read, Then Speak", stagesCompletedThisSession);
          }
          stopAllAudio();
          window.history.back();
        }
      }

      // Keyboard Support
      document.addEventListener("keydown", function (event) {
        if (
          !dataLoaded ||
          document.getElementById("quizContainer").style.display === "none"
        ) {
          return;
        }

        if (event.key === "Escape") {
          goBack();
        }
      });

      // Handle page unload - stop all audio
      window.addEventListener("beforeunload", function () {
        stopAllAudio();
      });

      window.addEventListener("unload", function () {
        stopAllAudio();
      });

      // Initialize App on Load
      window.addEventListener("load", function () {
        console.log("Read Then Speak Practice App loading...");

        // Wait for voices to load
        if (speechSynthesis.onvoiceschanged !== undefined) {
          speechSynthesis.onvoiceschanged = function () {
            console.log("Voices loaded:", speechSynthesis.getVoices().length);
          };
        }

        loadQuizData();
      });

      console.log("Read Then Speak Practice App initialized successfully!");
    </script>
  </body>
</html>
