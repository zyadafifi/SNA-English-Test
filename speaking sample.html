<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Speaking Sample - SNA English Test Practice</title>

    <!-- Resource Hints for Performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link rel="dns-prefetch" href="https://fonts.googleapis.com" />

    <!-- Preload Critical Assets -->
    <link
      rel="prefetch"
      href="speaking sample data.json"
      as="fetch"
      type="application/json"
    />

    <!-- Optimized Font Loading -->
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
      rel="stylesheet"
      media="print"
      onload="this.media='all'"
    />
    <noscript>
      <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
        rel="stylesheet"
      />
    </noscript>
    <link rel="stylesheet" href="background.css" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, sans-serif;
        background-color: #f8f9fa;
        min-height: 100vh;
        line-height: 1.6;
        color: #334155;
      }

      /* Loading Screen */
      .loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #f8f9fa;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      .loading-screen > div {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 20px;
      }

      .loading-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #e0e0e0;
        border-top: 4px solid #ffc515;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        flex-shrink: 0;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .loading-text {
        font-size: 16px;
        color: #6b7280;
        text-align: center;
        margin: 0;
      }

      /* Error Screen */
      .error-screen {
        display: none;
        text-align: center;
        padding: 40px;
        background-color: #ffebee;
        border-radius: 12px;
        border: 1px solid #f44336;
        margin: 20px;
      }

      .error-title {
        font-size: 24px;
        font-weight: 600;
        color: #f44336;
        margin-bottom: 10px;
      }

      .error-message {
        color: #6b7280;
        margin-bottom: 20px;
      }

      .retry-data-btn {
        background: #ffc515;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s;
      }

      .retry-data-btn:hover {
        background: #ffb300;
      }

      /* Quiz Container */
      .quiz-container {
        max-width: 100%;
        margin: 0 auto;
        padding: 40px;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: transparent;
      }

      /* Question Card */
      .question-card {
        background: white;
        border-radius: 12px 12px 0 0;
        padding: 50px 60px;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
        width: 100%;
        max-width: 1200px;
        text-align: center;
        position: relative;
        min-height: 600px;
        display: flex;
        margin: 0 auto;
        margin-bottom: 0;
        box-sizing: border-box;
        flex-direction: column;
        justify-content: center;
      }

      /* Timer */
      .timer {
        position: absolute;
        top: 30px;
        left: 30px;
        background: transparent;
        padding: 0;
        border-radius: 0;
        font-weight: 400;
        color: #888;
        font-size: 16px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .timer-icon {
        width: 20px;
        height: 20px;
        fill: currentColor;
      }

      .timer.warning {
        color: #f44336;
        font-weight: 600;
      }

      /* Close Button */
      .close-btn {
        position: absolute;
        top: 25px;
        right: 25px;
        background: none;
        border: none;
        cursor: pointer;
        padding: 8px;
        border-radius: 4px;
        transition: background 0.2s;
        color: #ddd;
      }

      .close-btn:hover {
        background: #f8f8f8;
      }

      /* Progress Bar */
      .stage-progress-bar {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 30px;
        width: 100%;
        max-width: 400px;
        margin-left: auto;
        margin-right: auto;
      }

      .progress-track {
        flex: 1;
        height: 8px;
        background: #e0e0e0;
        border-radius: 4px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        background: #ffc515;
        border-radius: 4px;
        transition: width 0.3s ease;
        width: 0%;
      }

      .progress-text {
        font-size: 14px;
        color: #666;
        font-weight: 500;
        min-width: 45px;
        text-align: right;
      }

      /* Question Content */
      .question-title {
        font-size: 28px;
        font-weight: 400;
        color: #6b7280;
        margin-bottom: 20px;
        line-height: 1.2;
      }

      .question-subtitle {
        font-size: 16px;
        color: #888;
        margin-bottom: 40px;
      }

      /* Topic Container */
      .topic-text {
        font-size: 16px;
        color: #495057;
        line-height: 1.7;
        margin-bottom: 20px;
        font-weight: 500;
        word-wrap: break-word;
        hyphens: auto;
      }

      /* Record Button Improvements */
      .record-button {
        background: #ffc515;
        color: white;
        border: none;
        padding: 16px 32px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s;
        text-transform: uppercase;
        letter-spacing: 1px;
        display: flex;
        align-items: center;
        gap: 8px;
        justify-content: center;
        margin: 0 auto;
        min-width: 180px;
        white-space: nowrap;
      }
      .record-button:hover {
        background: #ffb300;
        transform: translateY(-2px);
      }

      .record-button.recording {
        background: #f44336;
        animation: pulse 1.5s infinite;
      }

      @keyframes pulse {
        0% {
          box-shadow: 0 4px 20px rgba(244, 67, 54, 0.3);
        }
        50% {
          box-shadow: 0 4px 30px rgba(244, 67, 54, 0.6);
        }
        100% {
          box-shadow: 0 4px 20px rgba(244, 67, 54, 0.3);
        }
      }

      .record-icon {
        width: 20px;
        height: 20px;
        fill: currentColor;
        flex-shrink: 0;
      }

      /* Recording Status */
      .recording-status {
        display: none;
        align-items: center;
        justify-content: center;
        gap: 12px;
        margin: 20px 0;
        color: #ffc515;
        font-size: 16px;
        font-weight: 600;
        flex-wrap: wrap;
      }

      .recording-dot {
        width: 8px;
        height: 8px;
        background: #ffc515;
        border-radius: 50%;
        animation: blink 1s infinite;
      }

      @keyframes blink {
        0%,
        50% {
          opacity: 1;
        }
        51%,
        100% {
          opacity: 0.3;
        }
      }

      /* Continue Button */
      .continue-btn {
        background: #ffc515;
        color: white;
        border: none;
        padding: 14px 28px;
        border-radius: 9999px;
        font-size: 16px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s;
        text-transform: uppercase;
        letter-spacing: 1px;
        position: absolute;
        bottom: 30px;
        right: 30px;
        display: none;
        opacity: 0.5;
        pointer-events: none;
      }

      .continue-btn.active {
        display: block;
        opacity: 1;
        pointer-events: auto;
      }

      .continue-btn:hover {
        background: #ffb300;
      }

      .continue-btn:disabled {
        background: #e0e0e0;
        color: #999;
        cursor: not-allowed;
      }

      /* Review Section */
      .review-section {
        background: #ffe8b0;
        border-radius: 12px;
        padding: 28px 40px 80px 40px;
        margin: 20px auto 0 auto;
        border: none;
        display: none;
        position: relative;
        width: 100%;
        max-width: 900px;
        box-sizing: border-box;
        text-align: left;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
      }

      .review-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 16px;
      }

      .review-icon {
        width: 20px;
        height: 20px;
        flex-shrink: 0;
        fill: #2e7d32;
      }

      .review-title {
        font-size: 16px;
        font-weight: 700;
        margin: 0;
        color: #2e7d32;
      }

      .review-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-top: 16px;
        justify-content: flex-start;
      }

      .sample-btn,
      .recording-btn {
        background: white;
        color: #ffc515;
        border: 2px solid #ffc515;
        padding: 10px 18px;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 6px;
        white-space: nowrap;
        min-width: 120px;
        justify-content: center;
      }

      .sample-btn:hover,
      .recording-btn:hover {
        background: #ffc515;
        color: white;
      }

      .sample-btn.playing,
      .recording-btn.playing {
        background: #f44336;
        border-color: #f44336;
        color: white;
      }

      .play-icon,
      .stop-icon {
        width: 14px;
        height: 14px;
        fill: currentColor;
      }

      /* Continue Button in Review */
      .continue-review-btn {
        background: #ffc515;
        color: white;
        border: none;
        padding: 14px 24px;
        border-radius: 9999px;
        font-size: 14px;
        font-weight: 700;
        cursor: pointer;
        transition: background 0.2s;
        text-transform: uppercase;
        letter-spacing: 1px;
        position: absolute;
        bottom: 24px;
        right: 24px;
      }

      .continue-review-btn:hover {
        background: #ffb300;
      }

      /* Results Screen */
      .results-screen {
        display: none;
        text-align: center;
        background: white;
        border-radius: 12px;
        padding: 80px 60px;
        box-shadow: 0 4px 24px rgba(0, 0, 0, 0.08);
        width: 100%;
        max-width: 600px;
        min-height: 400px;
        position: relative;
      }

      .results-icon {
        width: 80px;
        height: 80px;
        margin: 0 auto 40px;
        background: #ffc515;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }

      .results-icon svg {
        width: 40px;
        height: 40px;
        fill: white;
      }

      .results-title {
        font-size: 24px;
        font-weight: 500;
        color: #777;
        margin-bottom: 10px;
        line-height: 1.3;
      }

      .results-subtitle {
        font-size: 18px;
        font-weight: 400;
        color: #777;
        margin-bottom: 60px;
      }

      .results-buttons {
        display: flex;
        flex-direction: row;
        gap: 16px;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        margin-top: 40px;
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
      }

      .results-buttons .results-continue-btn,
      .results-buttons .done-btn {
        position: static;
        bottom: auto;
        right: auto;
        left: auto;
      }

      .results-continue-btn {
        background: white;
        color: #ffc515;
        border: 2px solid #ffc515;
        padding: 14px 28px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .results-continue-btn:hover {
        background: #fff8e1;
      }

      .done-btn {
        background: #ffc515;
        color: white;
        border: none;
        padding: 14px 28px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 700;
        cursor: pointer;
        transition: background 0.2s;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .done-btn:hover {
        background: #ffb300;
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        .quiz-container {
          padding: 20px;
        }

        .question-card {
          padding: 35px 30px;
          min-height: 500px;
          border-radius: 12px 12px 0 0;
        }

        .question-title {
          font-size: 24px;
          margin-bottom: 16px;
        }

        .topic-container {
          padding: 20px;
          margin-bottom: 30px;
        }

        .continue-btn,
        .continue-review-btn,
        .done-btn {
          bottom: 20px;
          right: 20px;
          padding: 12px 24px;
          font-size: 14px;
        }

        .timer {
          top: 20px;
          left: 20px;
          font-size: 14px;
        }

        .close-btn {
          top: 15px;
          right: 15px;
        }
      }

      @media (max-width: 480px) {
        .quiz-container {
          padding: 10px;
        }

        .question-card {
          padding: 25px 20px;
          min-height: 450px;
          border-radius: 12px 12px 0 0;
        }

        .question-title {
          font-size: 20px;
          margin-bottom: 14px;
          line-height: 1.2;
        }

        .question-subtitle {
          font-size: 14px;
          margin-bottom: 25px;
        }

        /* Topic container for mobile */
        .topic-container {
          padding: 20px 18px;
          margin-bottom: 25px;
          border-radius: 8px;
          border-width: 1px;
        }

        .topic-text {
          font-size: 14px;
          line-height: 1.6;
          margin-bottom: 16px;
          font-weight: 500;
        }

        /* Record button for mobile */
        .record-button {
          padding: 12px 24px;
          font-size: 14px;
          min-width: 140px;
          gap: 4px;
        }

        .record-icon {
          width: 16px;
          height: 16px;
        }

        /* Recording status for mobile */
        .recording-status {
          font-size: 14px;
          margin: 16px 0;
          gap: 8px;
        }

        .recording-dot {
          width: 6px;
          height: 6px;
        }

        /* Review section for mobile */
        .review-section {
          padding: 20px 18px 70px 18px;
          margin: 12px 8px 0 8px;
          border-radius: 8px;
        }

        .review-header {
          gap: 8px;
          margin-bottom: 14px;
        }

        .review-icon {
          width: 18px;
          height: 18px;
        }

        .review-title {
          font-size: 15px;
        }

        .review-buttons {
          gap: 8px;
          flex-direction: column;
          align-items: stretch;
        }

        .sample-btn,
        .recording-btn {
          padding: 12px 16px;
          font-size: 13px;
          min-width: auto;
          width: 100%;
          justify-content: center;
        }

        .play-icon,
        .stop-icon {
          width: 12px;
          height: 12px;
        }

        /* Button positioning for mobile */
        .continue-btn,
        .done-btn {
          bottom: 15px;
          right: 15px;
          left: 15px;
          width: calc(100% - 30px);
          padding: 14px 20px;
          font-size: 14px;
          text-align: center;
        }

        .continue-review-btn {
          position: relative;
          bottom: auto;
          right: auto;
          left: auto;
          width: 100%;
          margin: 20px 0 0 0;
          padding: 14px 20px;
          font-size: 14px;
        }

        .timer {
          top: 15px;
          left: 15px;
          font-size: 13px;
        }

        .timer-icon {
          width: 16px;
          height: 16px;
        }

        .close-btn {
          top: 10px;
          right: 10px;
          padding: 6px;
        }

        .close-btn svg {
          width: 16px;
          height: 16px;
        }

        /* Results screen for mobile */
        .results-screen {
          padding: 40px 20px;
          margin: 10px 8px;
        }

        .results-icon {
          width: 60px;
          height: 60px;
          margin-bottom: 30px;
        }

        .results-icon svg {
          width: 30px;
          height: 30px;
        }

        .results-title {
          font-size: 20px;
          margin-bottom: 8px;
        }

        .results-subtitle {
          font-size: 16px;
          margin-bottom: 40px;
        }

        .stage-progress-bar {
          gap: 8px;
          max-width: 100%;
          margin-bottom: 20px;
        }

        .progress-track {
          height: 6px;
        }

        .progress-text {
          font-size: 12px;
          min-width: 35px;
        }

        .loading-spinner {
          width: 32px;
          height: 32px;
          border-width: 3px;
        }

        .loading-screen > div {
          gap: 16px;
        }

        .loading-text {
          font-size: 14px;
        }
      }
    </style>
  </head>
  <body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
      <div>
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading quiz data...</div>
      </div>
    </div>

    <!-- Error Screen -->
    <div class="error-screen" id="errorScreen">
      <div class="error-title">Failed to Load Quiz Data</div>
      <div class="error-message" id="errorMessage">
        Could not load the quiz questions. Please check your internet connection
        and try again.
      </div>
      <button class="retry-data-btn" onclick="loadQuizData()">Retry</button>
      <button
        class="retry-data-btn"
        onclick="goBack()"
        style="background: #f0f0f0; color: #666; margin-left: 10px"
      >
        Go Back
      </button>
    </div>

    <div class="quiz-container" id="quizContainer" style="display: none">
      <!-- Question Card -->
      <div class="question-card" id="questionCard">
        <!-- Timer -->
        <div class="timer" id="timer">
          <svg
            class="timer-icon"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <circle cx="12" cy="12" r="10" />
            <polyline points="12,6 12,12 16,14" />
          </svg>
          <span id="timerText">0:00</span>
          <span style="color: #999; margin-left: 6px" id="timerLabel"
            >to prepare</span
          >
        </div>

        <!-- Close Button -->
        <button class="close-btn" onclick="goBack()">
          <svg
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>

        <!-- Progress Bar -->
        <div class="stage-progress-bar">
          <div class="progress-track">
            <div class="progress-fill" id="stageProgressFill"></div>
          </div>
          <span class="progress-text" id="stageProgressText">0/3</span>
        </div>

        <!-- Question Content -->
        <div class="question-content" id="questionContent">
          <h1 class="question-title" id="questionTitle">
            Prepare to speak about the topic below
          </h1>

          <p class="question-subtitle" id="questionSubtitle">
            You will have 3 minutes to speak
          </p>

          <!-- Topic Container -->
          <div class="topic-container">
            <div class="topic-text" id="topicText">Loading question...</div>
          </div>

          <!-- Record Button -->
          <button
            class="record-button"
            id="recordButton"
            onclick="handleRecord()"
          >
            <span class="mic-icon">
              <svg height="24" width="24" viewBox="0 0 24 24">
                <path
                  fill-rule="evenodd"
                  clip-rule="evenodd"
                  d="M11.5055 0.921631C9.29632 0.921631 7.50546 2.71249 7.50546 4.92163V10.5029C7.50546 12.712 9.29632 14.5029 11.5055 14.5029H12.4973C14.7065 14.5029 16.4973 12.712 16.4973 10.5029V4.92163C16.4973 2.71249 14.7065 0.921631 12.4973 0.921631H11.5055ZM19.9809 12.4921C19.9809 11.9398 19.5332 11.4921 18.9809 11.4921C18.4286 11.4921 17.9809 11.9398 17.9809 12.4921C17.9809 14.924 16.0058 16.8983 13.566 16.8983H10.3052C7.93658 16.8983 6.01913 14.9816 6.01913 12.6206C6.01913 12.0683 5.57141 11.6206 5.01913 11.6206C4.46684 11.6206 4.01913 12.0683 4.01913 12.6206C4.01913 16.0892 6.83503 18.8983 10.3052 18.8983H10.9789V21.0783H10.2096C9.65732 21.0783 9.2096 21.526 9.2096 22.0783C9.2096 22.6305 9.65732 23.0783 10.2096 23.0783H13.9125C14.4648 23.0783 14.9125 22.6305 14.9125 22.0783C14.9125 21.526 14.4648 21.0783 13.9125 21.0783H12.9789V18.8983H13.566C17.1073 18.8983 19.9809 16.0316 19.9809 12.4921Z"
                  fill="currentcolor"
                ></path>
              </svg>
            </span>
            <span id="recordButtonText">RECORD NOW</span>
          </button>

          <!-- Recording Status -->
          <div class="recording-status" id="recordingStatus">
            <div class="recording-dot"></div>
            <span>RECORDING...</span>
          </div>

          <!-- Continue Button -->
          <button class="continue-btn" id="continueBtn" onclick="nextStep()">
            CONTINUE
          </button>
        </div>
      </div>

      <!-- Review Section -->
      <div class="review-section" id="reviewSection">
        <div class="review-header">
          <svg
            class="review-icon"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <circle cx="12" cy="12" r="10" />
            <polyline points="16,8 10,14 8,12" />
          </svg>
          <div class="review-title">Review sample answer:</div>
        </div>

        <div class="review-buttons">
          <button class="sample-btn" id="sampleBtn" onclick="toggleSample()">
            <svg class="play-icon" id="samplePlayIcon" viewBox="0 0 24 24">
              <polygon points="5,3 19,12 5,21"></polygon>
            </svg>
            <svg
              class="stop-icon"
              id="sampleStopIcon"
              viewBox="0 0 24 24"
              style="display: none"
            >
              <rect x="6" y="4" width="4" height="16"></rect>
              <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
            <span id="sampleBtnText">SAMPLE</span>
          </button>
          <button
            class="recording-btn"
            id="recordingBtn"
            onclick="toggleRecording()"
          >
            <svg class="play-icon" id="recordingPlayIcon" viewBox="0 0 24 24">
              <polygon points="5,3 19,12 5,21"></polygon>
            </svg>
            <svg
              class="stop-icon"
              id="recordingStopIcon"
              viewBox="0 0 24 24"
              style="display: none"
            >
              <rect x="6" y="4" width="4" height="16"></rect>
              <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
            <span id="recordingBtnText">YOUR RECORDING</span>
          </button>
        </div>

        <button class="continue-review-btn" onclick="showResults()">
          CONTINUE
        </button>
      </div>

      <!-- Results Screen -->
      <div class="results-screen" id="resultsScreen">
        <div class="results-icon">
          <svg viewBox="0 0 24 24">
            <path d="M8 5V19L19 12L8 5Z" />
          </svg>
        </div>
        <div class="results-title">Practice completed! You</div>
        <div class="results-subtitle">improved your speaking skills.</div>
        <div class="results-buttons">
          <button class="results-continue-btn" onclick="continueToNextStage()">CONTINUE</button>
          <button class="done-btn" onclick="goToPractice()">DONE</button>
        </div>
      </div>
    </div>

    <!-- Hidden Audio Elements -->
    <audio id="sampleAudio" preload="auto"></audio>
    <audio id="recordingAudio" preload="auto"></audio>

    <script>
      // Quiz State
      let allQuizData = [];
      let quizConfig = {};
      let currentQuestion = null;
      let currentStep = "prepare"; // prepare, speaking, review, results
      let questionStartTime = 0;
      let timerInterval;
      let prepareTimeout;
      let recordingTimeout;
      let mediaRecorder;
      let recordedChunks = [];
      let recordedBlob = null;
      let speechSynthesis = window.speechSynthesis;
      let currentUtterance = null;
      let sampleAudio = null;
      let recordingAudio = null;
      let isPlayingSample = false;
      let isPlayingRecording = false;
      let dataLoaded = false;
      let stagesCompletedThisSession = 0;
      // Session tracking variables
      let sessionStartTime = Date.now();
      let answers = []; // Array to store all responses
      let currentQuestionData = null; // Current question being answered

      // Response timing variables
      let questionPrepStartTime = 0;
      let questionSpeakStartTime = 0;
      let actualPreparationTime = 0;
      let actualSpeakingTime = 0;
      // Load Quiz Data from JSON
      async function loadQuizData() {
        try {
          showLoadingScreen();

          const response = await fetch("speaking sample data.json");
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();

          // Validate data structure
          if (
            !data.questions ||
            !Array.isArray(data.questions) ||
            data.questions.length === 0
          ) {
            throw new Error(
              "Invalid data format: questions array is missing or empty"
            );
          }

          allQuizData = data.questions;
          quizConfig = data.config || {};

          if (allQuizData.length === 0) {
            throw new Error("No questions available in the data file.");
          }

          dataLoaded = true;
          hideLoadingScreen();
          initializeQuiz();
        } catch (error) {
          console.error("Error loading quiz data:", error);
          showErrorScreen(error.message);
        }
      }

      // Show/Hide Loading Screen
      function showLoadingScreen() {
        document.getElementById("loadingScreen").style.display = "flex";
        document.getElementById("errorScreen").style.display = "none";
        document.getElementById("quizContainer").style.display = "none";
      }

      function hideLoadingScreen() {
        document.getElementById("loadingScreen").style.display = "none";
        document.getElementById("quizContainer").style.display = "flex";
      }

      function showErrorScreen(errorMessage) {
        document.getElementById("loadingScreen").style.display = "none";
        document.getElementById("quizContainer").style.display = "none";
        document.getElementById("errorScreen").style.display = "block";
        document.getElementById("errorMessage").textContent = errorMessage;
      }

      // Initialize Quiz (excludeQuestionId: optional ID to exclude when continuing)
      function initializeQuiz(excludeQuestionId) {
        if (!dataLoaded || allQuizData.length === 0) {
          showErrorScreen("No quiz data available");
          return;
        }

        // Initialize session tracking
        sessionStartTime = Date.now();
        answers = [];

        // Select a random question, excluding the one just completed if provided
        let available = allQuizData;
        if (excludeQuestionId != null && allQuizData.length > 1) {
          available = allQuizData.filter((q) => q.id !== excludeQuestionId);
        }
        currentQuestion =
          available[Math.floor(Math.random() * available.length)];
        showQuestion();
      }

      // Show Question
      // Update Progress Bar
      function updateProgressBar() {
        const completed = 0; // Single question quiz - always 0 until complete
        const total = 1;
        const percentage = 0;
        
        const progressFill = document.getElementById("stageProgressFill");
        const progressText = document.getElementById("stageProgressText");
        
        if (progressFill && progressText) {
          progressFill.style.width = percentage + "%";
          progressText.textContent = completed + "/" + total;
        }
      }

      function showQuestion() {
        currentStep = "prepare";

        // Update progress bar
        updateProgressBar();

        // Initialize question data tracking
        currentQuestionData = {
          questionId: currentQuestion.id,
          topicText: currentQuestion.topicText,
          sampleAnswer: currentQuestion.sampleAnswer,
          startTime: Date.now(),
          preparationStartTime: Date.now(),
        };

        // Reset timing variables
        questionPrepStartTime = Date.now();
        actualPreparationTime = 0;
        actualSpeakingTime = 0;

        resetUI();

        // Set topic content from loaded data
        document.getElementById("topicText").textContent =
          currentQuestion.topicText;

        // Set initial state - preparation mode
        document.getElementById("questionTitle").textContent =
          "Prepare to speak about the topic below";
        document.getElementById("questionSubtitle").textContent =
          "You will have " + quizConfig.speakingTime / 60 + " minutes to speak";
        document.getElementById("timerLabel").textContent = "to prepare";

        // Show record button, hide others
        document.getElementById("recordButton").style.display = "block";
        document.getElementById("recordingStatus").style.display = "none";
        document.getElementById("continueBtn").style.display = "none";

        // Hide review section and results
        document.getElementById("reviewSection").style.display = "none";
        document.getElementById("resultsScreen").style.display = "none";
        document.getElementById("questionCard").style.display = "flex";

        // Start prepare timer
        startPrepareTimer();
      }

      function resetUI() {
        clearInterval(timerInterval);
        clearTimeout(prepareTimeout);
        clearTimeout(recordingTimeout);
        stopAllAudio();

        const recordButton = document.getElementById("recordButton");
        recordButton.classList.remove("recording");
        recordButton.style.display = "block";

        document.getElementById("recordingStatus").style.display = "none";
        document.getElementById("continueBtn").style.display = "none";
        document.getElementById("timer").classList.remove("warning");

        if (mediaRecorder && mediaRecorder.state === "recording") {
          mediaRecorder.stop();
        }

        recordedChunks = [];
        recordedBlob = null;
      }

      function startPrepareTimer() {
        questionStartTime = Date.now();
        let seconds = 0;
        const maxSeconds = quizConfig.prepareTime || 30;

        timerInterval = setInterval(() => {
          seconds++;
          const minutes = Math.floor(seconds / 60);
          const remainingSeconds = seconds % 60;

          const timerElement = document.getElementById("timer");
          const timerText = document.getElementById("timerText");

          timerText.textContent = `${minutes}:${remainingSeconds
            .toString()
            .padStart(2, "0")}`;

          if (seconds >= maxSeconds) {
            clearInterval(timerInterval);
            startRecording();
          }
        }, 1000);

        prepareTimeout = setTimeout(() => {
          startRecording();
        }, (quizConfig.prepareTime || 30) * 1000);
      }

      async function handleRecord() {
        if (currentStep === "prepare") {
          clearTimeout(prepareTimeout);
          clearInterval(timerInterval);
          startRecording();
        }
      }

      async function startRecording() {
        currentStep = "speaking";

        // Track preparation time and start speaking time
        actualPreparationTime = Date.now() - questionPrepStartTime;
        questionSpeakStartTime = Date.now();

        document.getElementById("questionTitle").textContent =
          "Speak about the topic below";
        document.getElementById("questionSubtitle").textContent =
          "You have " + quizConfig.speakingTime / 60 + " minutes to speak";
        document.getElementById("recordButton").style.display = "none";
        document.getElementById("recordingStatus").style.display = "flex";
        document.getElementById("continueBtn").style.display = "block";
        document.getElementById("continueBtn").classList.remove("active");

        startRecordingTimer();

        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
          mediaRecorder = new MediaRecorder(stream);
          recordedChunks = [];

          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              recordedChunks.push(event.data);
            }
          };

          mediaRecorder.onstop = () => {
            recordedBlob = new Blob(recordedChunks, { type: "audio/wav" });
            stream.getTracks().forEach((track) => track.stop());

            // Calculate actual speaking time and save answer data
            actualSpeakingTime = Date.now() - questionSpeakStartTime;
            saveAnswerData();
          };

          mediaRecorder.start();
        } catch (error) {
          console.error("Error starting recording:", error);
          alert("Could not access microphone. Please check permissions.");
        }
      }

      function startRecordingTimer() {
        let seconds = 0;
        const maxSeconds = quizConfig.speakingTime || 180;

        document.getElementById("timerLabel").textContent = "to speak";
        document.getElementById("timer").classList.remove("warning");

        timerInterval = setInterval(() => {
          seconds++;
          const minutes = Math.floor(seconds / 60);
          const remainingSeconds = seconds % 60;

          const timerText = document.getElementById("timerText");
          timerText.textContent = `${minutes}:${remainingSeconds
            .toString()
            .padStart(2, "0")}`;

          // Enable continue button after configured time
          if (seconds >= (quizConfig.enableContinueAfter || 60)) {
            document.getElementById("continueBtn").classList.add("active");
          }

          if (seconds >= maxSeconds) {
            clearInterval(timerInterval);
            stopRecording();
          }
        }, 1000);

        recordingTimeout = setTimeout(() => {
          stopRecording();
        }, (quizConfig.speakingTime || 180) * 1000);
      }

      function stopRecording() {
        if (mediaRecorder && mediaRecorder.state === "recording") {
          mediaRecorder.stop();
        }

        clearInterval(timerInterval);
        clearTimeout(recordingTimeout);

        // Calculate actual speaking time if not already calculated
        if (actualSpeakingTime === 0) {
          actualSpeakingTime = Date.now() - questionSpeakStartTime;
          saveAnswerData();
        }

        document.getElementById("recordingStatus").style.display = "none";
      }
      function saveAnswerData() {
        const totalTime = actualPreparationTime + actualSpeakingTime;
        const maxSpeakingTime = (quizConfig.speakingTime || 180) * 1000; // Convert to milliseconds
        const timeUtilized = Math.min(
          (actualSpeakingTime / maxSpeakingTime) * 100,
          100
        );

        const answerData = {
          questionId: currentQuestion.id,
          topicText: currentQuestion.topicText,
          sampleAnswer: currentQuestion.sampleAnswer,
          preparationTime: actualPreparationTime,
          speakingTime: actualSpeakingTime,
          totalTime: totalTime,
          timeUtilized: Math.round(timeUtilized),
          timestamp: new Date().toISOString(),
        };

        answers.push(answerData);
        console.log("Answer data saved:", answerData);
      }

      function nextStep() {
        if (currentStep === "speaking") {
          stopRecording();
          showReview();
        }
      }

      function showReview() {
        currentStep = "review";
        document.getElementById("continueBtn").style.display = "none";
        document.getElementById("recordingStatus").style.display = "none";
        document.getElementById("reviewSection").style.display = "block";
      }

      function stopAllAudio() {
        if (speechSynthesis) {
          speechSynthesis.cancel();
        }

        if (sampleAudio) {
          sampleAudio.pause();
          sampleAudio.currentTime = 0;
        }

        if (recordingAudio) {
          recordingAudio.pause();
          recordingAudio.currentTime = 0;
        }

        resetAudioButtons();
        isPlayingSample = false;
        isPlayingRecording = false;
      }

      function resetAudioButtons() {
        const sampleBtn = document.getElementById("sampleBtn");
        const samplePlayIcon = document.getElementById("samplePlayIcon");
        const sampleStopIcon = document.getElementById("sampleStopIcon");
        const sampleBtnText = document.getElementById("sampleBtnText");

        if (sampleBtn) {
          sampleBtn.classList.remove("playing");
          samplePlayIcon.style.display = "block";
          sampleStopIcon.style.display = "none";
          sampleBtnText.textContent = "SAMPLE";
        }

        const recordingBtn = document.getElementById("recordingBtn");
        const recordingPlayIcon = document.getElementById("recordingPlayIcon");
        const recordingStopIcon = document.getElementById("recordingStopIcon");
        const recordingBtnText = document.getElementById("recordingBtnText");

        if (recordingBtn) {
          recordingBtn.classList.remove("playing");
          recordingPlayIcon.style.display = "block";
          recordingStopIcon.style.display = "none";
          recordingBtnText.textContent = "YOUR RECORDING";
        }
      }

      function toggleSample() {
        if (isPlayingSample) {
          stopAllAudio();
        } else {
          stopAllAudio();
          playSample();
        }
      }

      function playSample() {
        if (!speechSynthesis) {
          alert("Text-to-speech is not supported in your browser");
          return;
        }

        try {
          isPlayingSample = true;

          const sampleBtn = document.getElementById("sampleBtn");
          const samplePlayIcon = document.getElementById("samplePlayIcon");
          const sampleStopIcon = document.getElementById("sampleStopIcon");
          const sampleBtnText = document.getElementById("sampleBtnText");

          sampleBtn.classList.add("playing");
          samplePlayIcon.style.display = "none";
          sampleStopIcon.style.display = "block";
          sampleBtnText.textContent = "STOP";

          currentUtterance = new SpeechSynthesisUtterance(
            currentQuestion.sampleAnswer
          );
          currentUtterance.rate = 0.9;
          currentUtterance.pitch = 1.0;
          currentUtterance.volume = 0.8;

          const voices = speechSynthesis.getVoices();
          const englishVoice =
            voices.find(
              (voice) =>
                voice.lang.startsWith("en") && !voice.name.includes("Google")
            ) || voices.find((voice) => voice.lang.startsWith("en"));

          if (englishVoice) {
            currentUtterance.voice = englishVoice;
          }

          currentUtterance.onend = () => {
            isPlayingSample = false;
            resetAudioButtons();
          };

          currentUtterance.onerror = () => {
            isPlayingSample = false;
            resetAudioButtons();
          };

          speechSynthesis.speak(currentUtterance);
        } catch (error) {
          console.error("Error with text-to-speech:", error);
          alert("Error playing sample audio");
          isPlayingSample = false;
          resetAudioButtons();
        }
      }

      function toggleRecording() {
        if (isPlayingRecording) {
          stopAllAudio();
        } else {
          stopAllAudio();
          playRecording();
        }
      }

      function playRecording() {
        if (!recordedBlob) {
          alert("No recording available");
          return;
        }

        try {
          isPlayingRecording = true;

          const recordingBtn = document.getElementById("recordingBtn");
          const recordingPlayIcon =
            document.getElementById("recordingPlayIcon");
          const recordingStopIcon =
            document.getElementById("recordingStopIcon");
          const recordingBtnText = document.getElementById("recordingBtnText");

          recordingBtn.classList.add("playing");
          recordingPlayIcon.style.display = "none";
          recordingStopIcon.style.display = "block";
          recordingBtnText.textContent = "STOP";

          const audioUrl = URL.createObjectURL(recordedBlob);
          recordingAudio = document.getElementById("recordingAudio");
          recordingAudio.src = audioUrl;

          recordingAudio.onended = () => {
            isPlayingRecording = false;
            resetAudioButtons();
            URL.revokeObjectURL(audioUrl);
          };

          recordingAudio.onerror = () => {
            isPlayingRecording = false;
            resetAudioButtons();
            URL.revokeObjectURL(audioUrl);
          };

          recordingAudio.play();
        } catch (error) {
          console.error("Error playing recording:", error);
          alert("Error playing your recording");
          isPlayingRecording = false;
          resetAudioButtons();
        }
      }

      function showResults() {
        stagesCompletedThisSession++;
        saveDetailedQuizResult("Speaking Sample");

        stopAllAudio();
        document.getElementById("questionCard").style.display = "none";
        document.getElementById("reviewSection").style.display = "none";
        document.getElementById("resultsScreen").style.display = "block";
      }

      function continueToNextStage() {
        const completedId = currentQuestion?.id;
        resetUI();
        document.getElementById("resultsScreen").style.display = "none";
        document.getElementById("questionCard").style.display = "flex";
        initializeQuiz(completedId);
      }

      function goToPractice() {
        stopAllAudio();
        incrementSkillProgress("Speaking Sample", stagesCompletedThisSession);
        window.location.href = "index.html";
      }
      function saveDetailedQuizResult(skillName) {
        const sessionData = calculateSessionMetrics();

        // Create session result object
        const sessionResult = {
          skillName: skillName,
          sessionId: Date.now(),
          date: new Date().toISOString(),

          // Basic performance data
          totalQuestions: 1, // Speaking Sample typically has 1 question per session
          correctAnswers: 1, // All speaking responses are considered "completed"
          accuracy: 100, // Speaking tasks are evaluated differently

          // Time analysis
          totalTimeSpent: sessionData.totalTime,
          averageTimePerQuestion: sessionData.avgTime,

          // Performance analysis for speaking
          consistency: sessionData.consistency,
          difficultyHandling: sessionData.difficultyScore,
          speakingFluency: sessionData.speakingFluency,
          contentQuality: sessionData.contentQuality,
          timeUtilization: sessionData.timeUtilization,
          preparationEfficiency: sessionData.preparationEfficiency,

          // Final session score
          sessionScore: calculateSessionScore(sessionData),

          // Individual question details
          questionDetails: answers.map((answer, index) => ({
            questionId: answer.questionId,
            questionType: "speaking_sample",
            difficulty: determineTopicDifficulty(answer),
            speakingTime: answer.speakingTime,
            preparationTime: answer.preparationTime,
            totalTime: answer.totalTime,
            timeUtilized: answer.timeUtilized,
            topicType: categorizeTopicType(answer),
            sampleAnswer: answer.sampleAnswer,
            expectedElements: extractExpectedElements(answer.sampleAnswer),
          })),
        };

        // Save result to localStorage
        saveSessionToHistory(skillName, sessionResult);
        console.log(`Session saved for ${skillName}:`, sessionResult);
      }

      // =============================================================================
      // 9. ADD SESSION METRICS CALCULATION FUNCTIONS
      // =============================================================================

      function calculateSessionMetrics() {
        const totalTime = answers.reduce(
          (sum, answer) => sum + answer.totalTime,
          0
        );
        const avgTime = totalTime / answers.length;

        // Calculate consistency - how stable speaking times are
        const speakingTimes = answers.map((answer) => answer.speakingTime);
        const avgSpeakingTime =
          speakingTimes.reduce((sum, time) => sum + time, 0) /
          speakingTimes.length;

        const timeDeviations = speakingTimes.map((time) =>
          Math.abs(time - avgSpeakingTime)
        );
        const avgDeviation =
          timeDeviations.reduce((sum, dev) => sum + dev, 0) /
          timeDeviations.length;
        const consistency = Math.max(
          0,
          100 - (avgDeviation / avgSpeakingTime) * 100
        );

        // Calculate difficulty handling score
        const difficultyScore = calculateDifficultyHandling();

        // Calculate speaking fluency (based on time utilization)
        const speakingFluency = calculateSpeakingFluency();

        // Calculate content quality (estimated based on time usage patterns)
        const contentQuality = calculateContentQuality();

        // Calculate time utilization efficiency
        const timeUtilization = calculateTimeUtilization();

        // Calculate preparation efficiency
        const preparationEfficiency = calculatePreparationEfficiency();

        return {
          totalTime: Math.round(totalTime / 1000), // Convert to seconds
          avgTime: Math.round(avgTime / 1000), // Convert to seconds
          consistency: Math.round(consistency),
          difficultyScore: difficultyScore,
          speakingFluency: speakingFluency,
          contentQuality: contentQuality,
          timeUtilization: timeUtilization,
          preparationEfficiency: preparationEfficiency,
        };
      }

      // =============================================================================
      // 10. ADD TOPIC ANALYSIS FUNCTIONS
      // =============================================================================

      function determineTopicDifficulty(answer) {
        let difficulty = 1; // Base difficulty (Easy)

        const topicText = answer.topicText.toLowerCase();
        const sampleAnswer = answer.sampleAnswer.toLowerCase();

        // Analyze sample answer complexity
        const sampleWords = answer.sampleAnswer.split(" ").length;
        const sampleSentences = answer.sampleAnswer
          .split(/[.!?]+/)
          .filter((s) => s.trim().length > 0).length;

        // Length-based complexity for Speaking Sample (longer format)
        if (sampleWords > 120 || sampleSentences > 8) {
          difficulty += 1; // Complex celebrations/traditions
        } else if (sampleWords > 90 || sampleSentences > 6) {
          difficulty += 0.5; // Medium complexity
        }

        // Topic complexity indicators for celebrations/traditions
        const complexTopics = [
          "tradition",
          "culture",
          "ceremony",
          "ritual",
          "custom",
          "religious",
          "historical",
          "significance",
          "heritage",
          "ancestor",
          "spiritual",
          "symbolism",
          "generation",
          "community",
          "sacred",
        ];
        const hasComplexElements = complexTopics.some(
          (element) =>
            topicText.includes(element) || sampleAnswer.includes(element)
        );
        if (hasComplexElements) {
          difficulty += 0.5;
        }

        // Cultural/social complexity indicators
        const culturalTerms = [
          "traditional",
          "ancient",
          "ceremony",
          "festival",
          "celebration",
          "cultural",
          "social",
          "community",
          "family gathering",
          "reunion",
        ];
        if (
          culturalTerms.some(
            (term) => topicText.includes(term) || sampleAnswer.includes(term)
          )
        ) {
          difficulty += 0.3;
        }

        // Detailed description requirements
        const detailTerms = [
          "describe",
          "explain",
          "what happens",
          "how do people",
          "traditions",
          "customs",
          "activities",
          "procedures",
          "steps",
          "process",
        ];
        if (detailTerms.some((term) => topicText.includes(term))) {
          difficulty += 0.4;
        }

        // Clamp difficulty between 1-3
        difficulty = Math.max(1, Math.min(3, difficulty));

        if (difficulty <= 1.5) return "easy";
        if (difficulty <= 2.5) return "medium";
        return "hard";
      }

      function categorizeTopicType(answer) {
        const topicText = answer.topicText.toLowerCase();
        const sampleAnswer = answer.sampleAnswer.toLowerCase();

        if (
          topicText.includes("family") ||
          topicText.includes("birthday") ||
          topicText.includes("anniversary") ||
          sampleAnswer.includes("family")
        ) {
          return "family_celebrations";
        } else if (
          topicText.includes("holiday") ||
          topicText.includes("national") ||
          topicText.includes("independence") ||
          topicText.includes("country")
        ) {
          return "national_holidays";
        } else if (
          topicText.includes("wedding") ||
          topicText.includes("marriage") ||
          topicText.includes("ceremony") ||
          sampleAnswer.includes("wedding")
        ) {
          return "wedding_ceremonies";
        } else if (
          topicText.includes("religious") ||
          topicText.includes("festival") ||
          topicText.includes("spiritual") ||
          sampleAnswer.includes("religious")
        ) {
          return "religious_festivals";
        } else if (
          topicText.includes("graduation") ||
          topicText.includes("achievement") ||
          topicText.includes("success")
        ) {
          return "achievement_celebrations";
        } else if (
          topicText.includes("seasonal") ||
          topicText.includes("harvest") ||
          topicText.includes("spring") ||
          topicText.includes("winter")
        ) {
          return "seasonal_celebrations";
        }

        return "general_celebrations";
      }

      function extractExpectedElements(sampleAnswer) {
        const elements = [];
        const text = sampleAnswer.toLowerCase();

        // Key elements for celebration/tradition descriptions
        const settingElements = [
          "house",
          "home",
          "garden",
          "church",
          "park",
          "restaurant",
          "venue",
          "location",
          "place",
          "building",
        ];
        const peopleElements = [
          "family",
          "friends",
          "relatives",
          "guests",
          "children",
          "parents",
          "grandmother",
          "grandfather",
          "people",
          "everyone",
        ];
        const activityElements = [
          "celebrate",
          "gather",
          "eat",
          "dance",
          "sing",
          "play",
          "decorate",
          "prepare",
          "cook",
          "share",
          "stories",
          "photos",
        ];
        const emotionElements = [
          "happy",
          "joy",
          "special",
          "important",
          "together",
          "connected",
          "proud",
          "celebration",
          "fun",
          "wonderful",
        ];
        const traditionalElements = [
          "tradition",
          "custom",
          "ritual",
          "ceremony",
          "festival",
          "holiday",
          "celebration",
          "special",
          "cultural",
          "heritage",
        ];

        [
          settingElements,
          peopleElements,
          activityElements,
          emotionElements,
          traditionalElements,
        ].forEach((elementGroup) => {
          elementGroup.forEach((element) => {
            if (text.includes(element)) elements.push(element);
          });
        });

        return [...new Set(elements)]; // Remove duplicates
      }

      // =============================================================================
      // 11. ADD PERFORMANCE CALCULATION FUNCTIONS
      // =============================================================================

      function calculateDifficultyHandling() {
        const difficultyStats = {
          easy: { responses: 0, totalTime: 0, avgUtilization: 0 },
          medium: { responses: 0, totalTime: 0, avgUtilization: 0 },
          hard: { responses: 0, totalTime: 0, avgUtilization: 0 },
        };

        // Analyze performance by difficulty
        answers.forEach((answer) => {
          const difficulty = determineTopicDifficulty(answer);
          difficultyStats[difficulty].responses++;
          difficultyStats[difficulty].totalTime += answer.speakingTime;
          difficultyStats[difficulty].avgUtilization += answer.timeUtilized;
        });

        // Calculate weighted score based on difficulty handling
        let weightedScore = 0;
        let totalWeight = 0;

        Object.entries(difficultyStats).forEach(([difficulty, stats]) => {
          if (stats.responses > 0) {
            const avgTime = stats.totalTime / stats.responses;
            const avgUtilization = stats.avgUtilization / stats.responses;

            // Score based on appropriate time usage for difficulty level
            let difficultyScore = 50; // Base score

            // Time utilization bonus (using most of available time is good for longer format)
            if (avgUtilization > 75) {
              difficultyScore += 35;
            } else if (avgUtilization > 60) {
              difficultyScore += 25;
            } else if (avgUtilization > 40) {
              difficultyScore += 15;
            }

            // Consistency bonus for appropriate speaking time (longer for Speaking Sample)
            const expectedTime =
              difficulty === "easy"
                ? 120000 // 2 minutes
                : difficulty === "medium"
                ? 150000 // 2.5 minutes
                : 170000; // 2.8 minutes (milliseconds)
            if (Math.abs(avgTime - expectedTime) < expectedTime * 0.25) {
              difficultyScore += 15;
            }

            const weight =
              difficulty === "easy" ? 1 : difficulty === "medium" ? 1.5 : 2;
            weightedScore += difficultyScore * weight;
            totalWeight += weight;
          }
        });

        return totalWeight > 0 ? Math.round(weightedScore / totalWeight) : 0;
      }

      function calculateSpeakingFluency() {
        let fluencyScore = 0;
        let validResponses = 0;

        answers.forEach((answer) => {
          validResponses++;
          let responseScore = 0;

          // Time utilization score (using 60-90% of available time is optimal for longer format)
          const utilization = answer.timeUtilized;
          if (utilization >= 60 && utilization <= 90) {
            responseScore += 40;
          } else if (utilization >= 45 && utilization < 60) {
            responseScore += 25;
          } else if (utilization > 90) {
            responseScore += 30; // Good but might be rushed
          }

          // Consistency in speaking time (longer format allows more variation)
          const speakingTimeSeconds = answer.speakingTime / 1000;
          if (speakingTimeSeconds >= 120 && speakingTimeSeconds <= 170) {
            responseScore += 30;
          } else if (speakingTimeSeconds >= 90 && speakingTimeSeconds <= 120) {
            responseScore += 20;
          }

          // Preparation vs speaking time balance (longer preparation is acceptable)
          const prepRatio =
            answer.preparationTime /
            (answer.preparationTime + answer.speakingTime);
          if (prepRatio >= 0.08 && prepRatio <= 0.18) {
            // 8-18% preparation time is good for longer format
            responseScore += 20;
          } else if (prepRatio >= 0.05 && prepRatio <= 0.22) {
            responseScore += 15;
          }

          // Timing efficiency (not running over time limits)
          if (answer.speakingTime <= 182000) {
            // Within 182 seconds (allowing small buffer)
            responseScore += 10;
          }

          fluencyScore += Math.min(responseScore, 100);
        });

        return validResponses > 0
          ? Math.round(fluencyScore / validResponses)
          : 0;
      }

      function calculateContentQuality() {
        let qualityScore = 0;
        let validResponses = 0;

        answers.forEach((answer) => {
          validResponses++;
          let responseScore = 50; // Base score

          // Length appropriateness (longer speaking for detailed celebrations)
          const speakingTimeSeconds = answer.speakingTime / 1000;
          if (speakingTimeSeconds >= 120 && speakingTimeSeconds <= 170) {
            responseScore += 30; // Optimal length for detailed descriptions
          } else if (speakingTimeSeconds >= 90 && speakingTimeSeconds < 120) {
            responseScore += 20; // Good length
          } else if (speakingTimeSeconds >= 60 && speakingTimeSeconds < 90) {
            responseScore += 10; // Acceptable but brief
          }

          // Preparation time usage (good preparation for complex celebrations)
          const prepTimeSeconds = answer.preparationTime / 1000;
          if (prepTimeSeconds >= 15 && prepTimeSeconds <= 30) {
            responseScore += 15; // Good preparation time for longer format
          } else if (prepTimeSeconds >= 10 && prepTimeSeconds < 15) {
            responseScore += 10; // Some preparation
          }

          // Difficulty bonus (detailed celebration descriptions deserve more points)
          const difficulty = determineTopicDifficulty(answer);
          if (difficulty === "hard" && speakingTimeSeconds >= 120) {
            responseScore += 15;
          } else if (difficulty === "medium" && speakingTimeSeconds >= 90) {
            responseScore += 10;
          }

          qualityScore += Math.min(responseScore, 100);
        });

        return validResponses > 0
          ? Math.round(qualityScore / validResponses)
          : 0;
      }

      function calculateTimeUtilization() {
        const totalUtilization = answers.reduce(
          (sum, answer) => sum + answer.timeUtilized,
          0
        );
        return answers.length > 0
          ? Math.round(totalUtilization / answers.length)
          : 0;
      }

      function calculatePreparationEfficiency() {
        let efficiencyScore = 0;
        let validResponses = 0;

        answers.forEach((answer) => {
          validResponses++;
          const prepTime = answer.preparationTime / 1000; // Convert to seconds

          // Optimal preparation time is 15-25 seconds for Speaking Sample (longer format)
          if (prepTime >= 15 && prepTime <= 25) {
            efficiencyScore += 100;
          } else if (prepTime >= 10 && prepTime <= 30) {
            efficiencyScore += 85;
          } else if (prepTime >= 5 && prepTime <= 35) {
            efficiencyScore += 70;
          } else {
            efficiencyScore += 50; // Too little or too much preparation
          }
        });

        return validResponses > 0
          ? Math.round(efficiencyScore / validResponses)
          : 0;
      }

      function calculateSessionScore(sessionData) {
        // Scoring weights for Speaking Sample tasks (longer format)
        const weights = {
          speakingFluency: 0.28, // 28% - Important for longer speaking
          contentQuality: 0.3, // 30% - Most important for detailed descriptions
          timeUtilization: 0.18, // 18% - Using available time well
          preparationEfficiency: 0.12, // 12% - Good preparation for complex topics
          consistency: 0.08, // 8% - Less important for single question
          difficulty: 0.04, // 4% - Handling complex celebrations
        };

        // Calculate final weighted score
        const finalScore =
          sessionData.speakingFluency * weights.speakingFluency +
          sessionData.contentQuality * weights.contentQuality +
          sessionData.timeUtilization * weights.timeUtilization +
          sessionData.preparationEfficiency * weights.preparationEfficiency +
          sessionData.consistency * weights.consistency +
          sessionData.difficultyScore * weights.difficulty;

        return Math.round(Math.max(0, Math.min(100, finalScore)));
      }
      // =============================================================================
      // 12. ADD PROGRESS TRACKING FUNCTIONS
      // =============================================================================

      function incrementSkillProgress(skillName, count = 1) {
        // Get current progress first
        const currentProgress = getCurrentSkillProgress(skillName);
        const newCompleted = Math.min(currentProgress + count, 3); // Don't exceed 3

        const progressData = {
          skill: skillName,
          completed: newCompleted,
          total: 3,
          timestamp: new Date().toISOString(),
        };

        try {
          localStorage.setItem(
            "speakingSampleProgress",
            JSON.stringify(progressData)
          );
          console.log(`Progress updated: ${skillName} - ${newCompleted}/3`);
        } catch (error) {
          console.error("Error saving progress:", error);
        }
      }

      function getCurrentSkillProgress(skillName) {
        try {
          // Check if there's existing progress in the main app
          const mainProgressData = localStorage.getItem("skillProgress");
          if (mainProgressData) {
            const allProgress = JSON.parse(mainProgressData);
            if (allProgress[skillName]) {
              return allProgress[skillName].completed || 0;
            }
          }
          return 0;
        } catch (error) {
          console.error("Error reading current progress:", error);
          return 0;
        }
      }

      // =============================================================================
      // 13. ADD HISTORY AND ASSESSMENT FUNCTIONS
      // =============================================================================

      function saveSessionToHistory(skillName, sessionResult) {
        const historyKey = `${skillName
          .replace(/\s+/g, "_")
          .toLowerCase()}_sessions`;

        try {
          // Get existing sessions
          const existingSessions = localStorage.getItem(historyKey);
          const sessions = existingSessions ? JSON.parse(existingSessions) : [];

          // Add new session
          sessions.push(sessionResult);

          // Keep only last 20 sessions to prevent storage overflow
          if (sessions.length > 20) {
            sessions.splice(0, sessions.length - 20);
          }

          // Save back to localStorage
          localStorage.setItem(historyKey, JSON.stringify(sessions));

          console.log(
            `Saved session to ${historyKey}. Total sessions: ${sessions.length}`
          );

          // Update overall skill assessment
          updateSkillOverallAssessment(skillName, sessions);
        } catch (error) {
          console.error("Error saving session to history:", error);
        }
      }

      function updateSkillOverallAssessment(skillName, allSessions) {
        if (!allSessions || allSessions.length === 0) return;

        // Calculate overall metrics for Speaking Sample
        const avgSpeakingFluency =
          allSessions.reduce(
            (sum, session) => sum + session.speakingFluency,
            0
          ) / allSessions.length;

        const avgContentQuality =
          allSessions.reduce(
            (sum, session) => sum + session.contentQuality,
            0
          ) / allSessions.length;

        const avgTimeUtilization =
          allSessions.reduce(
            (sum, session) => sum + session.timeUtilization,
            0
          ) / allSessions.length;

        // Calculate improvement (compare first vs last session)
        const firstSession = allSessions[0];
        const lastSession = allSessions[allSessions.length - 1];
        const improvement =
          lastSession.contentQuality - firstSession.contentQuality; // Focus on content for celebrations

        // Calculate average session score
        const avgSessionScore =
          allSessions.reduce((sum, session) => sum + session.sessionScore, 0) /
          allSessions.length;

        // Calculate consistency across sessions
        const sessionScores = allSessions.map((s) => s.sessionScore);
        const scoreStdDev = calculateStandardDeviation(sessionScores);
        const crossSessionConsistency = Math.max(0, 100 - scoreStdDev);

        // Final skill score calculation
        const skillWeights = {
          speakingFluency: 0.3,
          contentQuality: 0.35, // Higher weight for detailed descriptions
          timeUtilization: 0.18,
          avgScore: 0.12,
          improvement: 0.05,
        };

        const normalizedImprovement = Math.max(
          0,
          Math.min(100, improvement + 50)
        ); // Normalize to 0-100

        const finalSkillScore =
          avgSpeakingFluency * skillWeights.speakingFluency +
          avgContentQuality * skillWeights.contentQuality +
          avgTimeUtilization * skillWeights.timeUtilization +
          avgSessionScore * skillWeights.avgScore +
          normalizedImprovement * skillWeights.improvement;

        // Create overall assessment
        const skillAssessment = {
          skillName: skillName,
          lastUpdated: new Date().toISOString(),
          sessionsCompleted: allSessions.length,

          // Performance metrics
          averageSpeakingFluency: Math.round(avgSpeakingFluency),
          averageContentQuality: Math.round(avgContentQuality),
          averageTimeUtilization: Math.round(avgTimeUtilization),
          averageSessionScore: Math.round(avgSessionScore),
          improvement: Math.round(improvement),
          consistency: Math.round(crossSessionConsistency),

          // Speaking Sample specific metrics
          averagePreparationEfficiency: Math.round(
            allSessions.reduce((sum, s) => sum + s.preparationEfficiency, 0) /
              allSessions.length
          ),
          averageSpeakingTime: Math.round(
            allSessions.reduce((sum, s) => sum + s.averageTimePerQuestion, 0) /
              allSessions.length
          ),

          // Final score
          finalScore: Math.round(finalSkillScore),
          level: determineSkillLevel(finalSkillScore),

          // Additional insights
          strongPoints: identifyStrongPoints(allSessions),
          weakPoints: identifyWeakPoints(allSessions),
          recommendations: generateRecommendations(
            allSessions,
            finalSkillScore
          ),
        };

        // Save overall assessment
        const assessmentKey = `${skillName
          .replace(/\s+/g, "_")
          .toLowerCase()}_assessment`;
        localStorage.setItem(assessmentKey, JSON.stringify(skillAssessment));

        console.log(
          `Updated overall assessment for ${skillName}:`,
          skillAssessment
        );
      }

      // Helper functions for assessment
      function calculateStandardDeviation(values) {
        const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
        const squaredDiffs = values.map((val) => Math.pow(val - mean, 2));
        const avgSquaredDiff =
          squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
        return Math.sqrt(avgSquaredDiff);
      }
      function determineSkillLevel(score) {
        if (score >= 90) return "Advanced";
        if (score >= 75) return "Upper-Intermediate";
        if (score >= 60) return "Intermediate";
        if (score >= 45) return "Lower-Intermediate";
        if (score >= 30) return "Elementary";
        return "Beginner";
      }

      function identifyStrongPoints(sessions) {
        const strongPoints = [];

        // Check speaking fluency
        const avgSpeakingFluency =
          sessions.reduce((sum, s) => sum + s.speakingFluency, 0) /
          sessions.length;
        if (avgSpeakingFluency >= 80) {
          strongPoints.push("Excellent speaking fluency and pacing");
        }

        // Check content quality
        const avgContentQuality =
          sessions.reduce((sum, s) => sum + s.contentQuality, 0) /
          sessions.length;
        if (avgContentQuality >= 75) {
          strongPoints.push(
            "Rich, detailed descriptions of celebrations and traditions"
          );
        }

        // Check time utilization
        const avgTimeUtilization =
          sessions.reduce((sum, s) => sum + s.timeUtilization, 0) /
          sessions.length;
        if (avgTimeUtilization >= 75) {
          strongPoints.push("Excellent use of available speaking time");
        }

        // Check preparation efficiency
        const avgPrepEfficiency =
          sessions.reduce((sum, s) => sum + s.preparationEfficiency, 0) /
          sessions.length;
        if (avgPrepEfficiency >= 85) {
          strongPoints.push("Efficient preparation for detailed topics");
        }

        // Check consistency
        const sessionScores = sessions.map((s) => s.sessionScore);
        const scoreStdDev = calculateStandardDeviation(sessionScores);
        if (scoreStdDev <= 12) {
          strongPoints.push(
            "Consistent performance across different celebration topics"
          );
        }

        // Check for long-format speaking ability
        const avgSpeakingTime =
          sessions.reduce((sum, s) => sum + s.averageTimePerQuestion, 0) /
          sessions.length;
        if (avgSpeakingTime >= 120) {
          strongPoints.push("Strong ability to maintain extended speaking");
        }

        return strongPoints.length > 0
          ? strongPoints
          : ["Shows potential for improvement in celebration descriptions"];
      }

      function identifyWeakPoints(sessions) {
        const weakPoints = [];

        // Check speaking fluency
        const avgSpeakingFluency =
          sessions.reduce((sum, s) => sum + s.speakingFluency, 0) /
          sessions.length;
        if (avgSpeakingFluency < 60) {
          weakPoints.push(
            "Speaking fluency needs improvement for longer responses"
          );
        }

        // Check content quality
        const avgContentQuality =
          sessions.reduce((sum, s) => sum + s.contentQuality, 0) /
          sessions.length;
        if (avgContentQuality < 65) {
          weakPoints.push(
            "Focus on providing more detailed celebration descriptions"
          );
        }

        // Check time utilization
        const avgTimeUtilization =
          sessions.reduce((sum, s) => sum + s.timeUtilization, 0) /
          sessions.length;
        if (avgTimeUtilization < 55) {
          weakPoints.push(
            "Try to use more of the 3-minute speaking time available"
          );
        } else if (avgTimeUtilization > 95) {
          weakPoints.push(
            "Practice pacing to avoid rushing through descriptions"
          );
        }

        // Check preparation efficiency
        const avgPrepEfficiency =
          sessions.reduce((sum, s) => sum + s.preparationEfficiency, 0) /
          sessions.length;
        if (avgPrepEfficiency < 70) {
          weakPoints.push(
            "Improve preparation time management for complex topics"
          );
        }

        // Check for brief responses
        const avgSpeakingTime =
          sessions.reduce((sum, s) => sum + s.averageTimePerQuestion, 0) /
          sessions.length;
        if (avgSpeakingTime < 90) {
          weakPoints.push(
            "Practice extending responses with more details and examples"
          );
        }

        return weakPoints.length > 0
          ? weakPoints
          : ["Keep practicing to maintain progress"];
      }

      function generateRecommendations(sessions, finalScore) {
        const recommendations = [];

        if (finalScore < 50) {
          recommendations.push(
            "Start with familiar celebrations (birthdays, holidays)"
          );
          recommendations.push(
            "Use the full 30-second preparation time to organize thoughts"
          );
          recommendations.push(
            "Practice describing who, what, when, where, and why"
          );
          recommendations.push(
            "Focus on simple, clear descriptions before adding details"
          );
        } else if (finalScore < 70) {
          recommendations.push(
            "Work on speaking for at least 2 minutes of the available time"
          );
          recommendations.push("Practice describing traditions step-by-step");
          recommendations.push(
            "Add more sensory details (what you see, hear, taste, smell)"
          );
          recommendations.push(
            "Include personal feelings and emotions about celebrations"
          );
        } else if (finalScore < 85) {
          recommendations.push(
            "Challenge yourself with complex cultural celebrations"
          );
          recommendations.push(
            "Practice comparing different celebrations or traditions"
          );
          recommendations.push(
            "Work on smooth transitions between different aspects"
          );
          recommendations.push(
            "Add historical or cultural context to your descriptions"
          );
        } else {
          recommendations.push(
            "Excellent work! Try discussing regional celebration variations"
          );
          recommendations.push("Practice with abstract celebration concepts");
          recommendations.push("Focus on cultural significance and symbolism");
          recommendations.push(
            "Help others improve their celebration description skills"
          );
        }

        // Specific recommendations based on metrics
        const avgTimeUtilization =
          sessions.reduce((sum, s) => sum + s.timeUtilization, 0) /
          sessions.length;
        if (avgTimeUtilization < 60) {
          recommendations.push(
            "Practice speaking for the full 3 minutes available"
          );
          recommendations.push(
            "Prepare mental lists of celebration activities and details"
          );
        }

        const avgPrepEfficiency =
          sessions.reduce((sum, s) => sum + s.preparationEfficiency, 0) /
          sessions.length;
        if (avgPrepEfficiency < 75) {
          recommendations.push(
            "Use preparation time to outline: setting, people, activities, significance"
          );
        }

        const avgContentQuality =
          sessions.reduce((sum, s) => sum + s.contentQuality, 0) /
          sessions.length;
        if (avgContentQuality < 70) {
          recommendations.push(
            "Include more specific examples and personal experiences"
          );
          recommendations.push(
            "Practice describing emotions and atmosphere of celebrations"
          );
        }

        return recommendations;
      }
      function goBack() {
        if (confirm("Are you sure you want to exit the quiz?")) {
          if (stagesCompletedThisSession > 0) {
            incrementSkillProgress("Speaking Sample", stagesCompletedThisSession);
          }
          stopAllAudio();
          window.history.back();
        }
      }

      // Initialize App on Load
      window.addEventListener("load", function () {
        if (speechSynthesis.onvoiceschanged !== undefined) {
          speechSynthesis.onvoiceschanged = function () {
            console.log("Voices loaded:", speechSynthesis.getVoices().length);
          };
        }

        loadQuizData();
      });
      // Function to update progress when quiz is completed
      function updateProgress() {
        const skillName = "Speaking Sample";
        const currentProgress = getSkillCurrentProgress(skillName);
        const newProgress = currentProgress + 1;
        const totalQuestions = 3; // Speaking Sample has 3 questions total

        // Save progress to localStorage for main page to read
        const progressData = {
          skill: skillName,
          completed: Math.min(newProgress, totalQuestions),
          total: totalQuestions,
          timestamp: new Date().toISOString(),
        };

        localStorage.setItem(
          "speakingSampleProgress",
          JSON.stringify(progressData)
        );

        console.log(
          `Speaking Sample progress updated: ${progressData.completed}/${progressData.total}`
        );
      }

      // Function to get current progress for Speaking Sample
      function getSkillCurrentProgress(skillName) {
        const progressKey = "skillProgress";

        try {
          const stored = localStorage.getItem(progressKey);
          if (stored) {
            const allProgress = JSON.parse(stored);
            if (allProgress[skillName]) {
              return allProgress[skillName].completed || 0;
            }
          }
        } catch (error) {
          console.error("Error reading current progress:", error);
        }

        return 0;
      }

      // Update the showResults function to call updateProgress
      const originalShowResults = showResults;
      showResults = function () {
        // Call original showResults function
        originalShowResults();

        // Update progress
        updateProgress();
      };
    </script>
  </body>
</html>
